SCRIPT  /usr/share/nvim/runtime/syntax/netrw.vim
Sourced 21 times
Total time:   0.003614
 Self time:   0.003614

count  total (s)   self (s)
                            " Language   : Netrw Listing Syntax
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Former Maintainer: Charles E. Campbell
                            " Last Change: Nov 07, 2019
                            "   2024 Feb 19 by Vim Project (announce adoption)
                            " Version    : 20
                            " ---------------------------------------------------------------------
   21              0.000062 if exists("b:current_syntax")
                             finish
   21              0.000008 endif
                            
                            " ---------------------------------------------------------------------
                            " Directory List Syntax Highlighting: {{{1
   21              0.000086 syn cluster NetrwGroup		contains=netrwHide,netrwSortBy,netrwSortSeq,netrwQuickHelp,netrwVersion,netrwCopyTgt
   21              0.000033 syn cluster NetrwTreeGroup	contains=netrwDir,netrwSymLink,netrwExe
                            
   21              0.000085 syn match  netrwPlain		"\(\S\+ \)*\S\+"					contains=netrwLink,@NoSpell
   21              0.000082 syn match  netrwSpecial		"\%(\S\+ \)*\S\+[*|=]\ze\%(\s\{2,}\|$\)"		contains=netrwClassify,@NoSpell
   21              0.000045 syn match  netrwDir		"\.\{1,2}/"						contains=netrwClassify,@NoSpell
   21              0.000055 syn match  netrwDir		"\%(\S\+ \)*\S\+/\ze\%(\s\{2,}\|$\)"			contains=netrwClassify,@NoSpell
   21              0.000068 syn match  netrwSizeDate	"\<\d\+\s\d\{1,2}/\d\{1,2}/\d\{4}\s"	skipwhite	contains=netrwDateSep,@NoSpell	nextgroup=netrwTime
   21              0.000048 syn match  netrwSymLink		"\%(\S\+ \)*\S\+@\ze\%(\s\{2,}\|$\)"  			contains=netrwClassify,@NoSpell
   21              0.000058 syn match  netrwExe		"\%(\S\+ \)*\S*[^~]\*\ze\%(\s\{2,}\|$\)" 		contains=netrwClassify,@NoSpell
   21              0.000070 if has("gui_running") && (&enc == 'utf-8' || &enc == 'utf-16' || &enc == 'ucs-4')
                            syn match  netrwTreeBar		"^\%([-+|â”‚] \)\+"					contains=netrwTreeBarSpace	nextgroup=@netrwTreeGroup
   21              0.000010 else
   21              0.000046 syn match  netrwTreeBar		"^\%([-+|] \)\+"					contains=netrwTreeBarSpace	nextgroup=@netrwTreeGroup
   21              0.000008 endif
   21              0.000027 syn match  netrwTreeBarSpace	" "					contained
                            
   21              0.000040 syn match  netrwClassify	"[*=|@/]\ze\%(\s\{2,}\|$\)"		contained
   21              0.000025 syn match  netrwDateSep		"/"					contained
   21              0.000044 syn match  netrwTime		"\d\{1,2}:\d\{2}:\d\{2}"		contained	contains=netrwTimeSep
   21              0.000018 syn match  netrwTimeSep		":"
                            
   21              0.000047 syn match  netrwComment		'".*\%(\t\|$\)'						contains=@NetrwGroup,@NoSpell
   21              0.000055 syn match  netrwHide		'^"\s*\(Hid\|Show\)ing:'	skipwhite		contains=@NoSpell		nextgroup=netrwHidePat
   21              0.000025 syn match  netrwSlash		"/"				contained
   21              0.000044 syn match  netrwHidePat		"[^,]\+"			contained skipwhite	contains=@NoSpell		nextgroup=netrwHideSep
   21              0.000026 syn match  netrwHideSep		","				contained skipwhite					nextgroup=netrwHidePat
   21              0.000041 syn match  netrwSortBy		"Sorted by"			contained transparent skipwhite				nextgroup=netrwList
   21              0.000040 syn match  netrwSortSeq		"Sort sequence:"		contained transparent skipwhite			 	nextgroup=netrwList
   21              0.000042 syn match  netrwCopyTgt		"Copy/Move Tgt:"		contained transparent skipwhite				nextgroup=netrwList
   21              0.000043 syn match  netrwList		".*$"				contained		contains=netrwComma,@NoSpell
   21              0.000023 syn match  netrwComma		","				contained
   21              0.000094 syn region netrwQuickHelp	matchgroup=Comment start="Quick Help:\s\+" end="$"	contains=netrwHelpCmd,netrwQHTopic,@NoSpell	keepend contained
   21              0.000044 syn match  netrwHelpCmd		"\S\+\ze:"			contained skipwhite	contains=@NoSpell		nextgroup=netrwCmdSep
   21              0.000044 syn match  netrwQHTopic		"([a-zA-Z &]\+)"		contained skipwhite
   21              0.000029 syn match  netrwCmdSep		":"				contained nextgroup=netrwCmdNote
   21              0.000038 syn match  netrwCmdNote		".\{-}\ze  "			contained		contains=@NoSpell
   21              0.000034 syn match  netrwVersion		"(netrw.*)"			contained		contains=@NoSpell
   21              0.000027 syn match  netrwLink		"-->"				contained skipwhite
                            
                            " -----------------------------
                            " Special filetype highlighting {{{1
                            " -----------------------------
   21              0.000046 if exists("g:netrw_special_syntax") && g:netrw_special_syntax
                             if exists("+suffixes") && &suffixes != ""
                              let suflist= join(split(&suffixes,','))
                              let suflist= escape(substitute(suflist," ",'\\|','g'),'.~')
                              exe "syn match netrwSpecFile '\\(\\S\\+ \\)*\\S*\\(".suflist."\\)\\>'  contains=netrwTreeBar,@NoSpell"
                             endif
                             syn match netrwBak		"\(\S\+ \)*\S\+\.bak\>"					contains=netrwTreeBar,@NoSpell
                             syn match netrwCompress	"\(\S\+ \)*\S\+\.\%(gz\|bz2\|Z\|zip\)\>"		contains=netrwTreeBar,@NoSpell
                             if has("unix")
                              syn match netrwCoreDump	"\<core\%(\.\d\+\)\=\>"					contains=netrwTreeBar,@NoSpell
                             endif
                             syn match netrwLex		"\(\S\+ \)*\S\+\.\%(l\|lex\)\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwYacc		"\(\S\+ \)*\S\+\.y\>"					contains=netrwTreeBar,@NoSpell
                             syn match netrwData		"\(\S\+ \)*\S\+\.dat\>"					contains=netrwTreeBar,@NoSpell
                             syn match netrwDoc		"\(\S\+ \)*\S\+\.\%(doc\|txt\|pdf\|ps\|docx\)\>"	contains=netrwTreeBar,@NoSpell
                             syn match netrwHdr		"\(\S\+ \)*\S\+\.\%(h\|hpp\)\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwLib		"\(\S\+ \)*\S*\.\%(a\|so\|lib\|dll\)\>"			contains=netrwTreeBar,@NoSpell
                             syn match netrwMakeFile	"\<[mM]akefile\>\|\(\S\+ \)*\S\+\.mak\>"		contains=netrwTreeBar,@NoSpell
                             syn match netrwObj		"\(\S\+ \)*\S*\.\%(o\|obj\)\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwPix		"\c\(\S\+ \)*\S*\.\%(bmp\|fits\=\|gif\|je\=pg\|pcx\|ppc\|pgm\|png\|ppm\|psd\|rgb\|tif\|xbm\|xcf\)\>"	contains=netrwTreeBar,@NoSpell
                             syn match netrwTags		"\<\(ANmenu\|ANtags\)\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwTags    	"\<tags\>"						contains=netrwTreeBar,@NoSpell
                             syn match netrwTilde		"\(\S\+ \)*\S\+\~\*\=\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwTmp		"\<tmp\(\S\+ \)*\S\+\>\|\(\S\+ \)*\S*tmp\>"		contains=netrwTreeBar,@NoSpell
   21              0.000009 endif
                            
                            " ---------------------------------------------------------------------
                            " Highlighting Links: {{{1
   21              0.000032 if !exists("did_drchip_netrwlist_syntax")
                             let did_drchip_netrwlist_syntax= 1
                             hi default link netrwClassify	Function
                             hi default link netrwCmdSep	Delimiter
                             hi default link netrwComment	Comment
                             hi default link netrwDir	Directory
                             hi default link netrwHelpCmd	Function
                             hi default link netrwQHTopic	Number
                             hi default link netrwHidePat	Statement
                             hi default link netrwHideSep	netrwComment
                             hi default link netrwList	Statement
                             hi default link netrwVersion	Identifier
                             hi default link netrwSymLink	Question
                             hi default link netrwExe	PreProc
                             hi default link netrwDateSep	Delimiter
                            
                             hi default link netrwTreeBar	Special
                             hi default link netrwTimeSep	netrwDateSep
                             hi default link netrwComma	netrwComment
                             hi default link netrwHide	netrwComment
                             hi default link netrwMarkFile	TabLineSel
                             hi default link netrwLink	Special
                            
                             " special syntax highlighting (see :he g:netrw_special_syntax)
                             hi default link netrwCoreDump	WarningMsg
                             hi default link netrwData	Folded
                             hi default link netrwHdr	netrwPlain
                             hi default link netrwLex	netrwPlain
                             hi default link netrwLib	DiffChange
                             hi default link netrwMakefile	DiffChange
                             hi default link netrwYacc	netrwPlain
                             hi default link netrwPix	Special
                            
                             hi default link netrwBak	netrwGray
                             hi default link netrwCompress	netrwGray
                             hi default link netrwSpecFile	netrwGray
                             hi default link netrwObj	netrwGray
                             hi default link netrwTags	netrwGray
                             hi default link netrwTilde	netrwGray
                             hi default link netrwTmp	netrwGray
   21              0.000007 endif
                            
                             " set up netrwGray to be understated (but not Ignore'd or Conceal'd, as those
                             " can be hard/impossible to read). Users may override this in a colorscheme by
                             " specifying netrwGray highlighting.
   21              0.000035  redir => s:netrwgray
   21              0.000060   sil hi netrwGray
   21              0.000029  redir END
   21              0.000040  if s:netrwgray !~ 'guifg'
   21              0.000041   if has("gui") && has("gui_running")
                               if &bg == "dark"
                                exe "hi netrwGray gui=NONE guifg=gray30"
                               else
                                exe "hi netrwGray gui=NONE guifg=gray70"
                               endif
   21              0.000007   else
   21              0.000018    hi link netrwGray	Folded
   21              0.000007   endif
   21              0.000006  endif
                            
                            " Current Syntax: {{{1
   21              0.000026 let   b:current_syntax = "netrwlist"
                            " ---------------------------------------------------------------------
                            " vim: ts=8 fdm=marker

SCRIPT  /home/guichina/.local/share/nvim/site/pack/packer/start/telescope.nvim/ftplugin/TelescopePrompt.lua
Sourced 1 time
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
                            -- Don't wrap textwidth things
                            vim.opt_local.formatoptions:remove "t"
                            vim.opt_local.formatoptions:remove "c"
                            
                            -- Don't include `showbreak` when calculating strdisplaywidth
                            vim.opt_local.wrap = false
                            
                            -- There's also no reason to enable textwidth here anyway
                            vim.opt_local.textwidth = 0
                            vim.opt_local.scrollbind = false
                            
                            vim.opt_local.signcolumn = "no"

SCRIPT  /home/guichina/.local/share/nvim/site/pack/packer/start/telescope.nvim/ftplugin/TelescopeResults.lua
Sourced 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
                            -- Don't have scrolloff, it makes things weird.
                            vim.opt_local.scrolloff = 0
                            vim.opt_local.scrollbind = false
                            
                            vim.opt_local.signcolumn = "no"

SCRIPT  /usr/share/nvim/runtime/ftplugin/lua.vim
Sourced 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            "			C.D. MacEachern <craig.daniel.maceachern@gmail.com>
                            "			Tyler Miller <tmillr@proton.me>
                            " Last Change:		2024 Jan 14
                            
    1              0.000002 if exists("b:did_ftplugin")
                              finish
    1              0.000000 endif
    1              0.000001 let b:did_ftplugin = 1
                            
    1              0.000001 let s:cpo_save = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000002 setlocal comments=:---,:--
    1              0.000002 setlocal commentstring=--\ %s
    1              0.000002 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000002 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
                            " TODO: handle init.lua
    1              0.000003 setlocal includeexpr=tr(v:fname,'.','/')
    1              0.000002 setlocal suffixesadd=.lua
                            
    1              0.000001 let b:undo_ftplugin = "setlocal cms< com< def< fo< inex< sua<"
                            
    1              0.000002 if exists("loaded_matchit") && !exists("b:match_words")
    1              0.000001   let b:match_ignorecase = 0
    1              0.000004   let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
    1              0.000002   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    1              0.000000 endif
                            
    1              0.000004 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
                              if has("win32")
                                let b:browsefilter ..= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter ..= "All Files (*)\t*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    1              0.000000 endif
                            
    1              0.000002 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/share/nvim/runtime/ftplugin/lua.lua
Sourced 1 time
Total time:   0.003899
 Self time:   0.003899

count  total (s)   self (s)
                            -- use treesitter over syntax
                            vim.treesitter.start()

SCRIPT  /usr/share/nvim/runtime/indent/lua.vim
Sourced 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            
                            " Only load this indent file when no other was loaded.
    1              0.000002 if exists("b:did_indent")
                              finish
    1              0.000000 endif
    1              0.000001 let b:did_indent = 1
                            
    1              0.000003 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    1              0.000002 setlocal indentkeys+=0=end,0=until
                            
    1              0.000003 setlocal autoindent
                            
    1              0.000001 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    1              0.000001 if exists("*GetLuaIndent")
                              finish
    1              0.000000 endif
                            
    1              0.000001 function! GetLuaIndent()
                                let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetLuaIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunction
                            
    1              0.000001 function! GetLuaIndentIntern()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '{\s*\%(--\%([^[].*\)\?\)\?$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until and '}'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

FUNCTION  netrw#CheckIfRemote()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:5573
Called 14 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
                            "  call Dfunc("netrw#CheckIfRemote() a:0=".a:0)
   14              0.000009   if a:0 > 0
                               let curfile= a:1
   14              0.000003   else
   14              0.000018    let curfile= expand("%")
   14              0.000004   endif
                            
                              " Ignore terminal buffers
   14              0.000012   if &buftype ==# 'terminal'
                                return 0
   14              0.000003   endif
                            "  call Decho("curfile<".curfile.">")
   14              0.000030   if curfile =~ '^\a\{3,}://'
                            "   call Dret("netrw#CheckIfRemote 1")
                               return 1
   14              0.000003   else
                            "   call Dret("netrw#CheckIfRemote 0")
   14              0.000005    return 0
                              endif

FUNCTION  <SNR>53_NetrwBufRename()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:5539
Called 16 times
Total time:   0.004777
 Self time:   0.000295

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBufRename(newname<".a:newname.">) buf(%)#".bufnr("%")."<".bufname(bufnr("%")).">")
                            "  call Dredir("ls!","s:NetrwBufRename (before rename)")
   16              0.000032   let oldbufname= bufname(bufnr("%"))
                            "  call Decho("buf#".bufnr("%").": oldbufname<".oldbufname.">",'~'.expand("<slnum>"))
                            
   16              0.000017   if oldbufname != a:newname
                            "   call Decho("do buffer rename: oldbufname<".oldbufname."> â‰  a:newname<".a:newname.">",'~'.expand("<slnum>"))
    3              0.000002    let b:junk= 1
                            "   call Decho("rename buffer: sil! keepj keepalt file ".fnameescape(a:newname),'~'.expand("<slnum>"))
    3   0.004584   0.000103    exe 'sil! keepj keepalt file '.fnameescape(a:newname)
                            "   call Dredir("ls!","s:NetrwBufRename (before bwipe)~".expand("<slnum>"))
    3              0.000012    let oldbufnr= bufnr(oldbufname)
                            "   call Decho("oldbufname<".oldbufname."> oldbufnr#".oldbufnr,'~'.expand("<slnum>"))
                            "   call Decho("bufnr(%)=".bufnr("%"),'~'.expand("<slnum>"))
    3              0.000006    if oldbufname != "" && oldbufnr != -1 && oldbufnr != bufnr("%")
                            "    call Decho("bwipe ".oldbufnr,'~'.expand("<slnum>"))
                                exe "bwipe! ".oldbufnr
                            "   else " Decho
                            "    call Decho("did *not* bwipe buf#".oldbufnr,'~'.expand("<slnum>"))
                            "    call Decho("..reason: if oldbufname<".oldbufname."> is empty",'~'.expand("<slnum>"))"
                            "    call Decho("..reason: if oldbufnr#".oldbufnr." is -1",'~'.expand("<slnum>"))"
                            "    call Decho("..reason: if oldbufnr#".oldbufnr." != bufnr(%)#".bufnr("%"),'~'.expand("<slnum>"))"
    3              0.000001    endif
                            "   call Dredir("ls!","s:NetrwBufRename (after rename)")
                            "  else " Decho
                            "   call Decho("oldbufname<".oldbufname."> == a:newname: did *not* rename",'~'.expand("<slnum>"))
   16              0.000004   endif
                            
                            "  call Dret("s:NetrwBufRename : buf#".bufnr("%").": oldname<".oldbufname."> newname<".a:newname."> expand(%)<".expand("%").">")

FUNCTION  <SNR>53_NetrwBookmarkMenu()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:4691
Called 7 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    7              0.000007   if !exists("s:netrw_menucnt")
    7              0.000003    return
                              endif
                            "  call Dfunc("NetrwBookmarkMenu()  histcnt=".g:netrw_dirhistcnt." menucnt=".s:netrw_menucnt)
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)",'~'.expand("<slnum>"))
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks'
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete'
                               endif
                               if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " show bookmarked places
                               if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmark.'.bmd.'	:e '.bmd,'~'.expand("<slnum>"))
                                 let bmd= escape(bmd,g:netrw_menu_escape)
                            
                                 " show bookmarks for goto menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks.'.bmd.'	:e '.bmd."\<cr>"
                            
                                 " show bookmarks for deletion menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".8.2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete.'.bmd.'	'.cnt."mB"
                                 let cnt= cnt + 1
                                endfor
                            
                               endif
                            
                               " show directory browsing history
                               if g:netrw_dirhistmax > 0
                                let cnt     = g:netrw_dirhistcnt
                                let first   = 1
                                let histcnt = 0
                                while ( first || cnt != g:netrw_dirhistcnt )
                                 let histcnt  = histcnt + 1
                                 let priority = g:netrw_dirhistcnt + histcnt
                                 if exists("g:netrw_dirhist_{cnt}")
                                  let histdir= escape(g:netrw_dirhist_{cnt},g:netrw_menu_escape)
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir,'~'.expand("<slnum>"))
                                  exe 'sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir."\<cr>"
                                 endif
                                 let first = 0
                                 let cnt   = ( cnt - 1 ) % g:netrw_dirhistmax
                                 if cnt < 0
                                  let cnt= cnt + g:netrw_dirhistmax
                                 endif
                                endwhile
                               endif
                            
                              endif
                            "  call Dret("NetrwBookmarkMenu")

FUNCTION  <SNR>53_NetrwFile()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:4036
Called 96 times
Total time:   0.001626
 Self time:   0.001626

count  total (s)   self (s)
                            "  "" call Dfunc("s:NetrwFile(fname<".a:fname.">) win#".winnr())
                            "  "" call Decho("g:netrw_keepdir  =".(exists("g:netrw_keepdir")?   g:netrw_keepdir   : 'n/a'),'~'.expand("<slnum>"))
                            "  "" call Decho("g:netrw_cygwin   =".(exists("g:netrw_cygwin")?    g:netrw_cygwin    : 'n/a'),'~'.expand("<slnum>"))
                            "  "" call Decho("g:netrw_liststyle=".(exists("g:netrw_liststyle")? g:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            "  "" call Decho("w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            
                              " clean up any leading treedepthstring
   96              0.000129   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               let fname= substitute(a:fname,'^'.s:treedepthstring.'\+','','')
                            "   "" call Decho("clean up any leading treedepthstring: fname<".fname.">",'~'.expand("<slnum>"))
   96              0.000025   else
   96              0.000059    let fname= a:fname
   96              0.000023   endif
                            
   96              0.000041   if g:netrw_keepdir
                               " vim's idea of the current directory possibly may differ from netrw's
   96              0.000085    if !exists("b:netrw_curdir")
    1              0.000003     let b:netrw_curdir= getcwd()
   96              0.000022    endif
                            
   96              0.000092    if !exists("g:netrw_cygwin") && has("win32")
                                if fname =~ '^\' || fname =~ '^\a:\'
                                 " windows, but full path given
                                 let ret= fname
                            "     "" call Decho("windows+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                else
                                 " windows, relative path given
                                 let ret= s:ComposePath(b:netrw_curdir,fname)
                            "     "" call Decho("windows+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                endif
                            
   96              0.000128    elseif fname =~ '^/'
                                " not windows, full path given
   96              0.000057     let ret= fname
                            "    "" call Decho("unix+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                               else
                                " not windows, relative path given
                                let ret= s:ComposePath(b:netrw_curdir,fname)
                            "    "" call Decho("unix+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
   96              0.000021    endif
                              else
                               " vim and netrw agree on the current directory
                               let ret= fname
                            "   "" call Decho("vim and netrw agree on current directory (g:netrw_keepdir=".g:netrw_keepdir.")",'~'.expand("<slnum>"))
                            "   "" call Decho("vim   directory: ".getcwd(),'~'.expand("<slnum>"))
                            "   "" call Decho("netrw directory: ".(exists("b:netrw_curdir")? b:netrw_curdir : 'n/a'),'~'.expand("<slnum>"))
   96              0.000020   endif
                            
                            "  "" call Dret("s:NetrwFile ".ret)
   96              0.000046   return ret

FUNCTION  <SNR>53_NetrwWideListing()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:9663
Called 7 times
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
                            
    7              0.000005   if w:netrw_liststyle == s:WIDELIST
                            "   call Dfunc("NetrwWideListing() w:netrw_liststyle=".w:netrw_liststyle.' fo='.&fo.' l:fo='.&l:fo)
                               " look for longest filename (cpf=characters per filename)
                               " cpf: characters per filename
                               " fpl: filenames per line
                               " fpc: filenames per column
                               setl ma noro
                               let keepa= @a
                            "   call Decho("setl ma noro",'~'.expand("<slnum>"))
                               let b:netrw_cpf= 0
                               if line("$") >= w:netrw_bannercnt
                                " determine the maximum filename size; use that to set cpf
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                NetrwKeepj call histdel("/",-1)
                               else
                                let @a= keepa
                            "    call Dret("NetrwWideListing")
                                return
                               endif
                               " allow for two spaces to separate columns
                               let b:netrw_cpf= b:netrw_cpf + 2
                            "   call Decho("b:netrw_cpf=max_filename_length+2=".b:netrw_cpf,'~'.expand("<slnum>"))
                            
                               " determine qty files per line (fpl)
                               let w:netrw_fpl= winwidth(0)/b:netrw_cpf
                               if w:netrw_fpl <= 0
                                let w:netrw_fpl= 1
                               endif
                            "   call Decho("fpl= [winwidth=".winwidth(0)."]/[b:netrw_cpf=".b:netrw_cpf.']='.w:netrw_fpl,'~'.expand("<slnum>"))
                            
                               " make wide display
                               "   fpc: files per column of wide listing
                               exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^.*$/\=escape(printf("%-'.b:netrw_cpf.'S",submatch(0)),"\\")/'
                               NetrwKeepj call histdel("/",-1)
                               let fpc         = (line("$") - w:netrw_bannercnt + w:netrw_fpl)/w:netrw_fpl
                               let newcolstart = w:netrw_bannercnt + fpc
                               let newcolend   = newcolstart + fpc - 1
                            "   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]",'~'.expand("<slnum>"))
                               while line("$") >= newcolstart
                                if newcolend > line("$") | let newcolend= line("$") | endif
                                let newcolqty= newcolend - newcolstart
                                exe newcolstart
                                " COMBAK: both of the visual-mode using lines below are problematic vis-a-vis @*
                                if newcolqty == 0
                                 exe "sil! NetrwKeepj norm! 0\<c-v>$h\"ax".w:netrw_bannercnt."G$\"ap"
                                else
                                 exe "sil! NetrwKeepj norm! 0\<c-v>".newcolqty.'j$h"ax'.w:netrw_bannercnt.'G$"ap'
                                endif
                                exe "sil! NetrwKeepj ".newcolstart.','.newcolend.'d _'
                                exe 'sil! NetrwKeepj '.w:netrw_bannercnt
                               endwhile
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$s/\s\+$//e'
                               NetrwKeepj call histdel("/",-1)
                               exe 'nno <buffer> <silent> w	:call search(''^.\\|\s\s\zs\S'',''W'')'."\<cr>"
                               exe 'nno <buffer> <silent> b	:call search(''^.\\|\s\s\zs\S'',''bW'')'."\<cr>"
                            "   call Decho("NetrwWideListing) setl noma nomod ro",'~'.expand("<slnum>"))
                               exe "setl ".g:netrw_bufsettings
                                let @a= keepa
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("NetrwWideListing")
                               return
    7              0.000002   else
    7              0.000015    if hasmapto("w","n")
    7              0.000055     sil! nunmap <buffer> w
    7              0.000002    endif
    7              0.000009    if hasmapto("b","n")
    7              0.000029     sil! nunmap <buffer> b
    7              0.000002    endif
    7              0.000002   endif
                            

FUNCTION  <SNR>53_NetrwBrowse()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:3734
Called 7 times
Total time:   0.102682
 Self time:   0.001524

count  total (s)   self (s)
    7              0.000017   if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
                            "  call Dfunc("s:NetrwBrowse(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".w:netrw_liststyle." ".g:loaded_netrw." buf#".bufnr("%")."<".bufname("%")."> win#".winnr())
                            "  call Decho("fyi: modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
                            "  call Decho("fyi: tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Dredir("ls!","s:NetrwBrowse")
                            
                              " save alternate-file's filename if w:netrw_rexlocal doesn't exist
                              " This is useful when one edits a local file, then :e ., then :Rex
    7              0.000013   if a:islocal && !exists("w:netrw_rexfile") && bufname("#") != ""
                               let w:netrw_rexfile= bufname("#")
                            "   call Decho("setting w:netrw_rexfile<".w:netrw_rexfile."> win#".winnr(),'~'.expand("<slnum>"))
    7              0.000002   endif
                            
                              " s:NetrwBrowse : initialize history {{{3
    7              0.000008   if !exists("s:netrw_initbookhist")
                               NetrwKeepj call s:NetrwBookHistRead()
    7              0.000002   endif
                            
                              " s:NetrwBrowse : simplify the dirname (especially for ".."s in dirnames) {{{3
    7              0.000021   if a:dirname !~ '^\a\{3,}://'
    7              0.000013    let dirname= simplify(a:dirname)
                            "   call Decho("simplified dirname<".dirname.">")
                              else
                               let dirname= a:dirname
    7              0.000002   endif
                            
                              " repoint t:netrw_lexbufnr if appropriate
    7              0.000011   if exists("t:netrw_lexbufnr") && bufnr("%") == t:netrw_lexbufnr
                            "   call Decho("set repointlexbufnr to true!")
                               let repointlexbufnr= 1
    7              0.000002   endif
                            
                              " s:NetrwBrowse : sanity checks: {{{3
    7              0.000007   if exists("s:netrw_skipbrowse")
                               unlet s:netrw_skipbrowse
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." filename<".expand("%")."> win#".winnr()." ft<".&ft.">",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwBrowse : s:netrw_skipbrowse existed")
                               return
    7              0.000002   endif
    7              0.000008   if !exists("*shellescape")
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing shellescape()",69)
                            "   call Dret("s:NetrwBrowse : missing shellescape()")
                               return
    7              0.000002   endif
    7              0.000007   if !exists("*fnameescape")
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing fnameescape()",70)
                            "   call Dret("s:NetrwBrowse : missing fnameescape()")
                               return
    7              0.000002   endif
                            
                              " s:NetrwBrowse : save options: {{{3
    7   0.000521   0.000023   call s:NetrwOptionsSave("w:")
                            
                              " s:NetrwBrowse : re-instate any marked files {{{3
    7              0.000016   if has("syntax") && exists("g:syntax_on") && g:syntax_on
    7              0.000017    if exists("s:netrwmarkfilelist_{bufnr('%')}")
                            "    call Decho("clearing marked files",'~'.expand("<slnum>"))
                                exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
    7              0.000002    endif
    7              0.000002   endif
                            
    7              0.000010   if a:islocal && exists("w:netrw_acdkeep") && w:netrw_acdkeep
                               " s:NetrwBrowse : set up "safe" options for local directory/file {{{3
                            "   call Decho("handle w:netrw_acdkeep:",'~'.expand("<slnum>"))
                            "   call Decho("NetrwKeepj lcd ".fnameescape(dirname)." (due to w:netrw_acdkeep=".w:netrw_acdkeep." - acd=".&acd.")",'~'.expand("<slnum>"))
                               if s:NetrwLcd(dirname)
                            "    call Dret("s:NetrwBrowse : lcd failure")
                                return
                               endif
                               "   call s:NetrwOptionsSafe() " tst952 failed with this enabled.
                            "   call Decho("getcwd<".getcwd().">",'~'.expand("<slnum>"))
                            
    7              0.000007   elseif !a:islocal && dirname !~ '[\/]$' && dirname !~ '^"'
                               " s:NetrwBrowse :  remote regular file handler {{{3
                            "   call Decho("handle remote regular file: dirname<".dirname.">",'~'.expand("<slnum>"))
                               if bufname(dirname) != ""
                            "    call Decho("edit buf#".bufname(dirname)." in win#".winnr(),'~'.expand("<slnum>"))
                                exe "NetrwKeepj b ".bufname(dirname)
                               else
                                " attempt transfer of remote regular file
                            "    call Decho("attempt transfer as regular file<".dirname.">",'~'.expand("<slnum>"))
                            
                                " remove any filetype indicator from end of dirname, except for the
                                " "this is a directory" indicator (/).
                                " There shouldn't be one of those here, anyway.
                                let path= substitute(dirname,'[*=@|]\r\=$','','e')
                            "    call Decho("new path<".path.">",'~'.expand("<slnum>"))
                                call s:RemotePathAnalysis(dirname)
                            
                                " s:NetrwBrowse : remote-read the requested file into current buffer {{{3
                                call s:NetrwEnew(dirname)
                                call s:NetrwOptionsSafe(a:islocal)
                                setl ma noro
                            "    call Decho("setl ma noro",'~'.expand("<slnum>"))
                                let b:netrw_curdir = dirname
                                let url            = s:method."://".((s:user == "")? "" : s:user."@").s:machine.(s:port ? ":".s:port : "")."/".s:path
                                call s:NetrwBufRename(url)
                                exe "sil! NetrwKeepj keepalt doau BufReadPre ".fnameescape(s:fname)
                                sil call netrw#NetRead(2,url)
                                " netrw.vim and tar.vim have already handled decompression of the tarball; avoiding gzip.vim error
                            "    call Decho("url<".url.">",'~'.expand("<slnum>"))
                            "    call Decho("s:path<".s:path.">",'~'.expand("<slnum>"))
                            "    call Decho("s:fname<".s:fname.">",'~'.expand("<slnum>"))
                                if s:path =~ '.bz2'
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.bz2$','',''))
                                elseif s:path =~ '.gz'
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.gz$','',''))
                                elseif s:path =~ '.gz'
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.txz$','',''))
                                else
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(s:fname)
                                endif
                               endif
                            
                               " s:NetrwBrowse : save certain window-oriented variables into buffer-oriented variables {{{3
                               call s:SetBufWinVars()
                               call s:NetrwOptionsRestore("w:")
                            "   call Decho("setl ma nomod",'~'.expand("<slnum>"))
                               setl ma nomod noro
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            
                            "   call Dret("s:NetrwBrowse : file<".s:fname.">")
                               return
    7              0.000002   endif
                            
                              " use buffer-oriented WinVars if buffer variables exist but associated window variables don't {{{3
    7   0.000188   0.000023   call s:UseBufWinVars()
                            
                              " set up some variables {{{3
    7              0.000008   let b:netrw_browser_active = 1
    7              0.000006   let dirname                = dirname
    7              0.000009   let s:last_sort_by         = g:netrw_sort_by
                            
                              " set up menu {{{3
    7   0.000534   0.000035   NetrwKeepj call s:NetrwMenu(1)
                            
                              " get/set-up buffer {{{3
                            "  call Decho("saving position across a buffer refresh",'~'.expand("<slnum>"))
    7              0.000013   let svpos  = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
    7   0.015233   0.000042   let reusing= s:NetrwGetBuffer(a:islocal,dirname)
                            
                              " maintain markfile highlighting
    7              0.000016   if has("syntax") && exists("g:syntax_on") && g:syntax_on
    7              0.000018    if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
                            " "   call Decho("bufnr(%)=".bufnr('%'),'~'.expand("<slnum>"))
                            " "   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/",'~'.expand("<slnum>"))
                                exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
    7              0.000002    else
                            " "   call Decho("2match none",'~'.expand("<slnum>"))
    7              0.000008     2match none
    7              0.000002    endif
    7              0.000002   endif
    7              0.000006   if reusing && line("$") > 1
                               call s:NetrwOptionsRestore("w:")
                            "   call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
                               setl noma nomod nowrap
                            "   call Decho("(set noma nomod nowrap)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwBrowse : re-using not-cleared buffer")
                               return
    7              0.000002   endif
                            
                              " set b:netrw_curdir to the new directory name {{{3
                            "  call Decho("set b:netrw_curdir to the new directory name<".dirname."> (buf#".bufnr("%").")",'~'.expand("<slnum>"))
    7              0.000010   let b:netrw_curdir= dirname
    7              0.000038   if b:netrw_curdir =~ '[/\\]$'
    7              0.000029    let b:netrw_curdir= substitute(b:netrw_curdir,'[/\\]$','','e')
    7              0.000002   endif
    7              0.000027   if b:netrw_curdir =~ '\a:$' && has("win32")
                               let b:netrw_curdir= b:netrw_curdir."/"
    7              0.000002   endif
    7              0.000005   if b:netrw_curdir == ''
                               if has("amiga")
                                " On the Amiga, the empty string connotes the current directory
                                let b:netrw_curdir= getcwd()
                               else
                                " under unix, when the root directory is encountered, the result
                                " from the preceding substitute is an empty string.
                                let b:netrw_curdir= '/'
                               endif
    7              0.000002   endif
    7              0.000006   if !a:islocal && b:netrw_curdir !~ '/$'
                               let b:netrw_curdir= b:netrw_curdir.'/'
    7              0.000002   endif
                            "  call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
                            
                              " ------------
                              " (local only) {{{3
                              " ------------
    7              0.000003   if a:islocal
                            "   call Decho("local only:",'~'.expand("<slnum>"))
                            
                               " Set up ShellCmdPost handling.  Append current buffer to browselist
    7   0.000170   0.000030    call s:LocalFastBrowser()
                            
                              " handle g:netrw_keepdir: set vim's current directory to netrw's notion of the current directory {{{3
    7              0.000004    if !g:netrw_keepdir
                            "    call Decho("handle g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                            "    call Decho("l:acd".(exists("&l:acd")? "=".&l:acd : " doesn't exist"),'~'.expand("<slnum>"))
                                if !exists("&l:acd") || !&l:acd
                                 if s:NetrwLcd(b:netrw_curdir)
                            "      call Dret("s:NetrwBrowse : lcd failure")
                                  return
                                 endif
                                endif
    7              0.000002    endif
                            
                              " --------------------------------
                              " remote handling: {{{3
                              " --------------------------------
                              else
                            "   call Decho("remote only:",'~'.expand("<slnum>"))
                            
                               " analyze dirname and g:netrw_list_cmd {{{3
                            "   call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist")."> dirname<".dirname.">",'~'.expand("<slnum>"))
                               if dirname =~# "^NetrwTreeListing\>"
                                let dirname= b:netrw_curdir
                            "    call Decho("(dirname was <NetrwTreeListing>) dirname<".dirname.">",'~'.expand("<slnum>"))
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                let dirname= substitute(b:netrw_curdir,'\\','/','g')
                                if dirname !~ '/$'
                                 let dirname= dirname.'/'
                                endif
                                let b:netrw_curdir = dirname
                            "    call Decho("(liststyle is TREELIST) dirname<".dirname.">",'~'.expand("<slnum>"))
                               else
                                let dirname = substitute(dirname,'\\','/','g')
                            "    call Decho("(normal) dirname<".dirname.">",'~'.expand("<slnum>"))
                               endif
                            
                               let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/]\+\)/\(.*\)$'
                               if dirname !~ dirpat
                                if !exists("g:netrw_quiet")
                                 NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw doesn't understand your dirname<".dirname.">",20)
                                endif
                                NetrwKeepj call s:NetrwOptionsRestore("w:")
                            "    call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
                                setl noma nomod nowrap
                            "    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwBrowse : badly formatted dirname<".dirname.">")
                                return
                               endif
                               let b:netrw_curdir= dirname
                            "   call Decho("b:netrw_curdir<".b:netrw_curdir."> (remote)",'~'.expand("<slnum>"))
    7              0.000003   endif  " (additional remote handling)
                            
                              " -------------------------------
                              " Perform Directory Listing: {{{3
                              " -------------------------------
    7   0.003353   0.000033   NetrwKeepj call s:NetrwMaps(a:islocal)
    7   0.000247   0.000113   NetrwKeepj call s:NetrwCommands(a:islocal)
    7   0.061858   0.000116   NetrwKeepj call s:PerformListing(a:islocal)
                            
                              " restore option(s)
    7   0.019478   0.000028   call s:NetrwOptionsRestore("w:")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            
                              " If there is a rexposn: restore position with rexposn
                              " Otherwise            : set rexposn
    7              0.000017   if exists("s:rexposn_".bufnr("%"))
                            "   call Decho("restoring posn to s:rexposn_".bufnr('%')."<".string(s:rexposn_{bufnr('%')}).">",'~'.expand("<slnum>"))
    4              0.000019    NetrwKeepj call winrestview(s:rexposn_{bufnr('%')})
    4              0.000007    if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
                                NetrwKeepj exe w:netrw_bannercnt
    4              0.000001    endif
    3              0.000001   else
    3   0.000036   0.000016    NetrwKeepj call s:SetRexDir(a:islocal,b:netrw_curdir)
    7              0.000002   endif
    7              0.000021   if v:version >= 700 && has("balloon_eval") && &beval == 0 && &l:bexpr == "" && !exists("g:netrw_nobeval")
                               let &l:bexpr= "netrw#BalloonHelp()"
                            "   call Decho("set up balloon help: l:bexpr=".&l:bexpr,'~'.expand("<slnum>"))
                               setl beval
    7              0.000002   endif
                            
                              " repoint t:netrw_lexbufnr if appropriate
    7              0.000006   if exists("repointlexbufnr")
                               let t:netrw_lexbufnr= bufnr("%")
                            "   call Decho("repoint t:netrw_lexbufnr to #".t:netrw_lexbufnr)
    7              0.000001   endif
                            
                              " restore position
    7              0.000003   if reusing
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               call winrestview(svpos)
    7              0.000002   endif
                            
                              " The s:LocalBrowseRefresh() function is called by an autocmd
                              " installed by s:LocalFastBrowser() when g:netrw_fastbrowse <= 1 (ie. slow or medium speed).
                              " However, s:NetrwBrowse() causes the FocusGained event to fire the first time.
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwBrowse : did PerformListing  ft<".&ft.">")
    7              0.000003   return

FUNCTION  <SNR>53_NetrwGetBuffer()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:4164
Called 7 times
Total time:   0.015191
 Self time:   0.000721

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwGetBuffer(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".g:netrw_liststyle)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." hid=".&hid,'~'.expand("<slnum>"))
                            "  call Decho("netrwbuf dictionary=".(exists("s:netrwbuf")? string(s:netrwbuf) : 'n/a'),'~'.expand("<slnum>"))
                            "  call Dredir("ls!","s:NetrwGetBuffer")
    7              0.000007   let dirname= a:dirname
                            
                              " re-use buffer if possible {{{3
                            "  call Decho("--re-use a buffer if possible--",'~'.expand("<slnum>"))
    7              0.000009   if !exists("s:netrwbuf")
                            "   call Decho("  s:netrwbuf initialized to {}",'~'.expand("<slnum>"))
                               let s:netrwbuf= {}
    7              0.000002   endif
                            "  call Decho("  s:netrwbuf         =".string(s:netrwbuf),'~'.expand("<slnum>"))
                            "  call Decho("  w:netrw_liststyle  =".(exists("w:netrw_liststyle")? w:netrw_liststyle : "n/a"),'~'.expand("<slnum>"))
                            
    7              0.000011   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               let bufnum = -1
                            
                               if !empty(s:netrwbuf) && has_key(s:netrwbuf,s:NetrwFullPath(dirname))
                                if has_key(s:netrwbuf,"NetrwTreeListing")
                                 let bufnum= s:netrwbuf["NetrwTreeListing"]
                                else
                                 let bufnum= s:netrwbuf[s:NetrwFullPath(dirname)]
                                endif
                            "    call Decho("  NetrwTreeListing: bufnum#".bufnum,'~'.expand("<slnum>"))
                                if !bufexists(bufnum)
                                 call remove(s:netrwbuf,"NetrwTreeListing"])
                                 let bufnum= -1
                                endif
                               elseif bufnr("NetrwTreeListing") != -1
                                let bufnum= bufnr("NetrwTreeListing")
                            "    call Decho("  NetrwTreeListing".": bufnum#".bufnum,'~'.expand("<slnum>"))
                               else
                            "    call Decho("  did not find a NetrwTreeListing buffer",'~'.expand("<slnum>"))
                                 let bufnum= -1
                               endif
                            
    7   0.000123   0.000036   elseif has_key(s:netrwbuf,s:NetrwFullPath(dirname))
    4   0.000055   0.000017    let bufnum= s:netrwbuf[s:NetrwFullPath(dirname)]
                            "   call Decho("  lookup netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."]=".bufnum,'~'.expand("<slnum>"))
    4              0.000005    if !bufexists(bufnum)
                                call remove(s:netrwbuf,s:NetrwFullPath(dirname))
                                let bufnum= -1
    4              0.000001    endif
                            
    3              0.000001   else
                            "   call Decho("  lookup netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."] not a key",'~'.expand("<slnum>"))
    3              0.000002    let bufnum= -1
    7              0.000002   endif
                            "  call Decho("  bufnum#".bufnum,'~'.expand("<slnum>"))
                            
                              " highjack the current buffer
                              "   IF the buffer already has the desired name
                              "   AND it is empty
    7              0.000009   let curbuf = bufname("%")
    7              0.000005   if curbuf == '.'
                               let curbuf = getcwd()
    7              0.000002   endif
                            "  call Dredir("ls!","NetrwGetFile (renamed buffer back to remote filename<".rfile."> : expand(%)<".expand("%").">)")
                            "  call Decho("deciding if netrw may highjack the current buffer#".bufnr("%")."<".curbuf.">",'~'.expand("<slnum>"))
                            "  call Decho("..dirname<".dirname.">  IF dirname == bufname",'~'.expand("<slnum>"))
                            "  call Decho("..curbuf<".curbuf.">",'~'.expand("<slnum>"))
                            "  call Decho("..line($)=".line("$")." AND this is 1",'~'.expand("<slnum>"))
                            "  call Decho("..getline(%)<".getline("%").">  AND this line is empty",'~'.expand("<slnum>"))
    7              0.000010   if dirname == curbuf && line("$") == 1 && getline("%") == ""
                            "   call Dret("s:NetrwGetBuffer 0<cleared buffer> : highjacking buffer#".bufnr("%"))
                               return 0
    7              0.000003   else  " DEBUG
                            "   call Decho("..did NOT highjack buffer",'~'.expand("<slnum>"))
    7              0.000002   endif
                              " Aug 14, 2021: was thinking about looking for a [No Name] buffer here and using it, but that might cause problems
                            
                              " get enew buffer and name it -or- re-use buffer {{{3
    7              0.000004   if bufnum < 0      " get enew buffer and name it
                            "   call Decho("--get enew buffer and name it  (bufnum#".bufnum."<0 OR bufexists(".bufnum.")=".bufexists(bufnum)."==0)",'~'.expand("<slnum>"))
    3   0.013059   0.000035    call s:NetrwEnew(dirname)
                            "   call Decho("  got enew buffer#".bufnr("%")." (altbuf<".expand("#").">)",'~'.expand("<slnum>"))
                               " name the buffer
    3              0.000007    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                " Got enew buffer; transform into a NetrwTreeListing
                            "    call Decho("--transform enew buffer#".bufnr("%")." into a NetrwTreeListing --",'~'.expand("<slnum>"))
                                let w:netrw_treebufnr = bufnr("%")
                                call s:NetrwBufRename("NetrwTreeListing")
                                if g:netrw_use_noswf
                                 setl nobl bt=nofile noswf
                                else
                                 setl nobl bt=nofile
                                endif
                                nnoremap <silent> <buffer> [[       :sil call <SID>TreeListMove('[[')<cr>
                                nnoremap <silent> <buffer> ]]       :sil call <SID>TreeListMove(']]')<cr>
                                nnoremap <silent> <buffer> []       :sil call <SID>TreeListMove('[]')<cr>
                                nnoremap <silent> <buffer> ][       :sil call <SID>TreeListMove('][')<cr>
                            "    call Decho("  tree listing bufnr=".w:netrw_treebufnr,'~'.expand("<slnum>"))
    3              0.000001    else
    3   0.000060   0.000028     call s:NetrwBufRename(dirname)
                                " enter the new buffer into the s:netrwbuf dictionary
    3   0.000075   0.000034     let s:netrwbuf[s:NetrwFullPath(dirname)]= bufnr("%")
                            "    call Decho("update netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."]=".bufnr("%"),'~'.expand("<slnum>"))
                            "    call Decho("netrwbuf dictionary=".string(s:netrwbuf),'~'.expand("<slnum>"))
    3              0.000001    endif
                            "   call Decho("  named enew buffer#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            
    4              0.000002   else " Re-use the buffer
                            "   call Decho("--re-use buffer#".bufnum." (bufnum#".bufnum.">=0 AND bufexists(".bufnum.")=".bufexists(bufnum)."!=0)",'~'.expand("<slnum>"))
                               " ignore all events
    4              0.000004    let eikeep= &ei
    4              0.000012    setl ei=all
                            
    4              0.000004    if &ft == "netrw"
                            "    call Decho("buffer type is netrw; not using keepalt with b ".bufnum)
    4              0.000018     exe "sil! NetrwKeepj noswapfile b ".bufnum
                            "    call Dredir("ls!","one")
                               else
                            "    call Decho("buffer type is not netrw; using keepalt with b ".bufnum)
                                call s:NetrwEditBuf(bufnum)
                            "    call Dredir("ls!","two")
    4              0.000001    endif
                            "   call Decho("  line($)=".line("$"),'~'.expand("<slnum>"))
    4              0.000004    if bufname("%") == '.'
                                call s:NetrwBufRename(getcwd())
    4              0.000001    endif
                            
                               " restore ei
    4              0.000010    let &ei= eikeep
                            
    4              0.000008    if line("$") <= 1 && getline(1) == ""
                                " empty buffer
    4   0.000219   0.000021     NetrwKeepj call s:NetrwListSettings(a:islocal)
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 0<buffer empty> : re-using buffer#".bufnr("%").", but its empty, so refresh it")
    4              0.000003     return 0
                            
                               elseif g:netrw_fastbrowse == 0 || (a:islocal && g:netrw_fastbrowse == 1)
                            "    call Decho("g:netrw_fastbrowse=".g:netrw_fastbrowse." a:islocal=".a:islocal.": clear buffer",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwListSettings(a:islocal)
                                sil NetrwKeepj %d _
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but refreshing due to g:netrw_fastbrowse=".g:netrw_fastbrowse)
                                return 0
                            
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "    call Decho("--re-use tree listing--",'~'.expand("<slnum>"))
                            "    call Decho("  clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                                setl ma
                                sil NetrwKeepj %d _
                                NetrwKeepj call s:NetrwListSettings(a:islocal)
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but treelist mode always needs a refresh")
                                return 0
                            
                               else
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 1<buffer not cleared>")
                                return 1
                               endif
    3              0.000001   endif
                            
                              " do netrw settings: make this buffer not-a-file, modifiable, not line-numbered, etc {{{3
                              "     fastbrowse  Local  Remote   Hiding a buffer implies it may be re-used (fast)
                              "  slow   0         D      D      Deleting a buffer implies it will not be re-used (slow)
                              "  med    1         D      H
                              "  fast   2         H      H
                            "  call Decho("--do netrw settings: make this buffer#".bufnr("%")." not-a-file, modifiable, not line-numbered, etc--",'~'.expand("<slnum>"))
    3              0.000004   let fname= expand("%")
    3   0.001058   0.000032   NetrwKeepj call s:NetrwListSettings(a:islocal)
    3   0.000036   0.000011   call s:NetrwBufRename(fname)
                            
                              " delete all lines from buffer {{{3
                            "  call Decho("--delete all lines from buffer--",'~'.expand("<slnum>"))
                            "  call Decho("  clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
    3              0.000011   sil! keepalt NetrwKeepj %d _
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwGetBuffer 0<cleared buffer>")
    3              0.000005   return 0

FUNCTION  <SNR>53_LocalFastBrowser()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:10900
Called 7 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
                            "  call Dfunc("s:LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse)
                            "  call Decho("s:netrw_events        ".(exists("s:netrw_events")? "exists"            : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("autocmd: ShellCmdPost ".(exists("#ShellCmdPost")?  "already installed" : "not installed"),'~'.expand("<slnum>"))
                            "  call Decho("autocmd: FocusGained  ".(exists("#FocusGained")?   "already installed" : "not installed"),'~'.expand("<slnum>"))
                            
                              " initialize browselist, a list of buffer numbers that the local browser has used
    7              0.000011   if !exists("s:netrw_browselist")
                            "   call Decho("initialize s:netrw_browselist",'~'.expand("<slnum>"))
                               let s:netrw_browselist= []
    7              0.000002   endif
                            
                              " append current buffer to fastbrowse list
    7              0.000016   if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
                            "   call Decho("appendng current buffer to browselist",'~'.expand("<slnum>"))
    3              0.000005    call add(s:netrw_browselist,bufnr("%"))
                            "   call Decho("browselist=".string(s:netrw_browselist),'~'.expand("<slnum>"))
    7              0.000002   endif
                            
                              " enable autocmd events to handle refreshing/removing local browser buffers
                              "    If local browse buffer is currently showing: refresh it
                              "    If local browse buffer is currently hidden : wipe it
                              "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
                              "                      =1 : medium speed, re-use directory listing for remote only
                              "                      =2 : fast   speed, always re-use directory listing when possible
    7              0.000016   if g:netrw_fastbrowse <= 1 && !exists("#ShellCmdPost") && !exists("s:netrw_events")
                               let s:netrw_events= 1
                               augroup AuNetrwEvent
                                au!
                                if has("win32")
                            "     call Decho("installing autocmd: ShellCmdPost",'~'.expand("<slnum>"))
                                 au ShellCmdPost			*	call s:LocalBrowseRefresh()
                                else
                            "     call Decho("installing autocmds: ShellCmdPost FocusGained",'~'.expand("<slnum>"))
                                 au ShellCmdPost,FocusGained	*	call s:LocalBrowseRefresh()
                                endif
                               augroup END
                            
                              " user must have changed fastbrowse to its fast setting, so remove
                              " the associated autocmd events
    7              0.000009   elseif g:netrw_fastbrowse > 1 && exists("#ShellCmdPost") && exists("s:netrw_events")
                            "   call Decho("remove AuNetrwEvent autcmd group",'~'.expand("<slnum>"))
                               unlet s:netrw_events
                               augroup AuNetrwEvent
                                au!
                               augroup END
                               augroup! AuNetrwEvent
    7              0.000002   endif
                            
                            "  call Dret("s:LocalFastBrowser : browselist<".string(s:netrw_browselist).">")

FUNCTION  <SNR>53_LocalBrowseRefresh()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:10807
Called 6 times
Total time:   0.073632
 Self time:   0.000682

count  total (s)   self (s)
                            "  call Dfunc("s:LocalBrowseRefresh() tabpagenr($)=".tabpagenr("$"))
                            "  call Decho("s:netrw_browselist =".(exists("s:netrw_browselist")?  string(s:netrw_browselist)  : '<n/a>'),'~'.expand("<slnum>"))
                            "  call Decho("w:netrw_bannercnt  =".(exists("w:netrw_bannercnt")?   string(w:netrw_bannercnt)   : '<n/a>'),'~'.expand("<slnum>"))
                            
                              " determine which buffers currently reside in a tab
    6              0.000049   if !exists("s:netrw_browselist")
                            "   call Dret("s:LocalBrowseRefresh : browselist is empty")
                               return
    6              0.000005   endif
    6              0.000012   if !exists("w:netrw_bannercnt")
                            "   call Dret("s:LocalBrowseRefresh : don't refresh when focus not on netrw window")
                               return
    6              0.000002   endif
    6              0.000015   if !empty(getcmdwintype())
                                " cannot move away from cmdline window, see :h E11
                                return
    6              0.000002   endif
    6              0.000019   if exists("s:netrw_events") && s:netrw_events == 1
                               " s:LocalFastBrowser gets called (indirectly) from a
                               let s:netrw_events= 2
                            "   call Dret("s:LocalBrowseRefresh : avoid initial double refresh")
                               return
    6              0.000002   endif
    6              0.000010   let itab       = 1
    6              0.000008   let buftablist = []
    6              0.000013   let ykeep      = @@
   12              0.000031   while itab <= tabpagenr("$")
    6              0.000023    let buftablist = buftablist + tabpagebuflist()
    6              0.000007    let itab       = itab + 1
    6              0.000013    sil! tabn
   12              0.000008   endwhile
                            "  call Decho("buftablist".string(buftablist),'~'.expand("<slnum>"))
                            "  call Decho("s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">",'~'.expand("<slnum>"))
                              "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
                              "   | refresh any netrw window
                              "   | wipe out any non-displaying netrw buffer
    6              0.000014   let curwinid = win_getid(winnr())
    6              0.000004   let ibl    = 0
   14              0.000021   for ibuf in s:netrw_browselist
                            "   call Decho("bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf),'~'.expand("<slnum>"))
    8              0.000020    if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
                                " wipe out any non-displaying netrw buffer
                                " (ibuf not shown in a current window AND
                                "  ibuf not in any tab)
                            "    call Decho("wiping  buf#".ibuf,"<".bufname(ibuf).">",'~'.expand("<slnum>"))
    4              0.000024     exe "sil! keepj bd ".fnameescape(ibuf)
    4              0.000007     call remove(s:netrw_browselist,ibl)
                            "    call Decho("browselist=".string(s:netrw_browselist),'~'.expand("<slnum>"))
    4              0.000002     continue
    4              0.000009    elseif index(tabpagebuflist(),ibuf) != -1
                                " refresh any netrw buffer
                            "    call Decho("refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf),'~'.expand("<slnum>"))
    4              0.000022     exe bufwinnr(ibuf)."wincmd w"
    4              0.000023     if getline(".") =~# 'Quick Help'
                                 " decrement g:netrw_quickhelp to prevent refresh from changing g:netrw_quickhelp
                                 " (counteracts s:NetrwBrowseChgDir()'s incrementing)
                                 let g:netrw_quickhelp= g:netrw_quickhelp - 1
    4              0.000001     endif
                            "    call Decho("#3: quickhelp=".g:netrw_quickhelp,'~'.expand("<slnum>"))
    4              0.000008     if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                 NetrwKeepj call s:NetrwRefreshTreeDict(w:netrw_treetop)
    4              0.000001     endif
    4   0.073005   0.000055     NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
    4              0.000001    endif
    4              0.000004    let ibl= ibl + 1
                            "   call Decho("bottom of s:netrw_browselist for loop: ibl=".ibl,'~'.expand("<slnum>"))
   10              0.000006   endfor
                            "  call Decho("restore window: win_gotoid(".curwinid.")")
    6              0.000008   call win_gotoid(curwinid)
    6              0.000007   let @@= ykeep
                            
                            "  call Dret("s:LocalBrowseRefresh")

FUNCTION  <SNR>53_NetrwEditFile()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:5677
Called 4 times
Total time:   0.031172
 Self time:   0.001843

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwEditFile(cmd<".a:cmd.">,opt<".a:opt.">,fname<".a:fname.">)  ft<".&ft.">")
    4              0.000006   if exists("g:netrw_altfile") && g:netrw_altfile && &ft == "netrw"
                            "   call Decho("exe NetrwKeepj keepalt ".a:opt." ".a:cmd." ".fnameescape(a:fname))
                               exe "NetrwKeepj keepalt ".a:opt." ".a:cmd." ".fnameescape(a:fname)
    4              0.000001   else
                            "   call Decho("exe NetrwKeepj ".a:opt." ".a:cmd." ".fnameescape(a:fname))
    4   0.031152   0.001823    exe "NetrwKeepj ".a:opt." ".a:cmd." ".fnameescape(a:fname)
    4              0.000002   endif
                            "  call Dret("s:NetrwEditFile")

FUNCTION  <SNR>16_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:44
Called 73 times
Total time:   0.004229
 Self time:   0.003700

count  total (s)   self (s)
   73              0.000289   if !exists("w:matchparen_ids")
    2              0.000004     let w:matchparen_ids = []
   73              0.000039   endif
                              " Remove any previous match.
   73   0.000794   0.000266   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   73              0.000187   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   73              0.000018   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   73              0.000122   let c_lnum = line('.')
   73              0.000085   let c_col = col('.')
   73              0.000042   let before = 0
                            
   73              0.000111   let text = getline(c_lnum)
   73              0.000575   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   73              0.000085   if empty(matches)
                                let [c_before, c] = ['', '']
   73              0.000027   else
   73              0.000180     let [c_before, c] = matches[1:2]
   73              0.000023   endif
   73              0.000556   let plist = split(&matchpairs, '.\zs[:,]')
   73              0.000117   let i = index(plist, c)
   73              0.000043   if i < 0
                                " not found, in Insert mode try character before the cursor
   73              0.000111     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   12              0.000018       let before = strlen(c_before)
   12              0.000008       let c = c_before
   12              0.000013       let i = index(plist, c)
   73              0.000022     endif
   73              0.000035     if i < 0
                                  " not found, nothing to do
   73              0.000041       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if s:has_matchaddpos
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>16_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:206
Called 85 times
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
   85              0.000187   if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
   85              0.000026   endif

FUNCTION  <SNR>53_NetrwEnew()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:11931
Called 3 times
Total time:   0.013024
 Self time:   0.000323

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwEnew() a:0=".a:0." win#".winnr()." winnr($)=".winnr("$")." bufnr($)=".bufnr("$")." expand(%)<".expand("%").">")
                            "  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            
                              " Clean out the last buffer: 
                              " Check if the last buffer has # > 1, is unlisted, is unnamed, and does not appear in a window
                              " If so, delete it.
    3   0.000032   0.000014   call s:NetrwBufRemover(bufnr("$"))
                            
                              " grab a function-local-variable copy of buffer variables
                            "  call Decho("make function-local copy of netrw variables",'~'.expand("<slnum>"))
    3              0.000008   if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
    3              0.000007   if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
    3              0.000005   if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
    3              0.000006   if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
    3              0.000005   if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
    3              0.000005   if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
    3              0.000004   if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
    3              0.000004   if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
    3              0.000005   if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
    3              0.000005   if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
    3              0.000004   if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
    3              0.000004   if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
    3              0.000006   if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
    3              0.000004   if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
    3              0.000004   if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
    3              0.000006   if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif
                            
    3   0.001831   0.000014   NetrwKeepj call s:NetrwOptionsRestore("w:")
                            "  call Decho("generate a buffer with NetrwKeepj enew!",'~'.expand("<slnum>"))
                              " when tree listing uses file TreeListing... a new buffer is made.
                              " Want the old buffer to be unlisted.
                              " COMBAK: this causes a problem, see P43
                            "  setl nobl
    3              0.000002   let netrw_keepdiff= &l:diff
    3   0.006055   0.000014   call s:NetrwEditFile("enew!","","")
    3   0.000014   0.000010   let &l:diff= netrw_keepdiff
                            "  call Decho("bufnr($)=".bufnr("$")."<".bufname(bufnr("$"))."> winnr($)=".winnr("$"),'~'.expand("<slnum>"))
    3   0.000198   0.000017   NetrwKeepj call s:NetrwOptionsSave("w:")
                            
                              " copy function-local-variables to buffer variable equivalents
                            "  call Decho("copy function-local variables back to buffer netrw variables",'~'.expand("<slnum>"))
    3              0.000007   if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
    3              0.000006   if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
    3              0.000004   if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
    3              0.000005   if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
    3              0.000004   if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
    3              0.000004   if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
    3              0.000004   if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
    3              0.000004   if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
    3              0.000004   if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
    3              0.000004   if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
    3              0.000004   if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
    3              0.000004   if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
    3              0.000005   if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
    3              0.000004   if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
    3              0.000003   if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
    3              0.000005   if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif
                            
    3              0.000002   if a:0 > 0
    3              0.000002    let b:netrw_curdir= a:1
    3              0.000008    if b:netrw_curdir =~ '/$'
    3              0.000004     if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                 setl nobl
                                 file NetrwTreeListing
                                 setl nobl bt=nowrite bh=hide
                                 nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
                                 nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
    3              0.000001     else
    3   0.004668   0.000029      call s:NetrwBufRename(b:netrw_curdir)
    3              0.000001     endif
    3              0.000001    endif
    3              0.000001   endif
    3              0.000013   if v:version >= 700 && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on")
                               let &l:bexpr = "netrw#BalloonHelp()"
    3              0.000001   endif
                            
                            "  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))

FUNCTION  <SNR>53_NetrwLcd()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:12064
Called 18 times
Total time:   0.000461
 Self time:   0.000461

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwLcd(newdir<".a:newdir.">)")
                            "  call Decho("changing local directory",'~'.expand("<slnum>"))
                            
   18              0.000014   let err472= 0
   18              0.000009   try
   18              0.000141    exe 'NetrwKeepj sil lcd '.fnameescape(a:newdir)
                              catch /^Vim\%((\a\+)\)\=:E344/
                                 " Vim's lcd fails with E344 when attempting to go above the 'root' of a Windows share.
                                 " Therefore, detect if a Windows share is present, and if E344 occurs, just settle at
                                 " 'root' (ie. '\').  The share name may start with either backslashes ('\\Foo') or
                                 " forward slashes ('//Foo'), depending on whether backslashes have been converted to
                                 " forward slashes by earlier code; so check for both.
                                 if has("win32") && !g:netrw_cygwin
                                   if a:newdir =~ '^\\\\\w\+' || a:newdir =~ '^//\w\+'
                                     let dirname = '\'
                                     exe 'NetrwKeepj sil lcd '.fnameescape(dirname)
                                   endif
                                 endif
                              catch /^Vim\%((\a\+)\)\=:E472/
                               let err472= 1
   18              0.000011   endtry
                            
   18              0.000010   if err472
                               call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".a:newdir."> (permissions?)",61)
                               if exists("w:netrw_prvdir")
                                let a:newdir= w:netrw_prvdir
                               else
                                call s:NetrwOptionsRestore("w:")
                            "    call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
                                exe "setl ".g:netrw_bufsettings
                            "    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                let a:newdir= dirname
                               endif
                            "   call Dret("s:NetrwBrowse -1 : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
                               return -1
   18              0.000005   endif
                            
                            "  call Decho("getcwd        <".getcwd().">")
                            "  call Decho("b:netrw_curdir<".b:netrw_curdir.">")
                            "  call Dret("s:NetrwLcd 0")
   18              0.000009   return 0

FUNCTION  <SNR>53_NetrwBufRemover()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:11914
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBufRemover(".a:bufid.")")
                            "  call Decho("buf#".a:bufid."           ".((a:bufid > 1)? ">" : "â‰¯")." must be >1 for removal","~".expand("<slnum>"))
                            "  call Decho("buf#".a:bufid." is        ".(buflisted(a:bufid)? "listed" : "unlisted"),"~".expand("<slnum>"))
                            "  call Decho("buf#".a:bufid." has name <".bufname(a:bufid).">","~".expand("<slnum>"))
                            "  call Decho("buf#".a:bufid." has winid#".bufwinid(a:bufid),"~".expand("<slnum>"))
                            
    3              0.000010   if a:bufid > 1 && !buflisted(a:bufid) && bufloaded(a:bufid) && bufname(a:bufid) == "" && bufwinid(a:bufid) == -1
                            "   call Decho("(s:NetrwBufRemover) removing buffer#".a:bufid,"~".expand("<slnum>"))
                               exe "sil! bd! ".a:bufid
    3              0.000001   endif
                            
                            "  call Dret("s:NetrwBufRemover")

FUNCTION  <SNR>53_NetrwGetWord()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:4366
Called 4 times
Total time:   0.000537
 Self time:   0.000384

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwGetWord() liststyle=".s:ShowStyle()." virtcol=".virtcol("."))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
    4              0.000017   let keepsol= &l:sol
    4   0.000032   0.000015   setl nosol
                            
    4   0.000155   0.000024   call s:UseBufWinVars()
                            
                              " insure that w:netrw_liststyle is set up
    4              0.000005   if !exists("w:netrw_liststyle")
                               if exists("g:netrw_liststyle")
                                let w:netrw_liststyle= g:netrw_liststyle
                               else
                                let w:netrw_liststyle= s:THINLIST
                               endif
                            "   call Decho("w:netrw_liststyle=".w:netrw_liststyle,'~'.expand("<slnum>"))
    4              0.000001   endif
                            
    4              0.000010   if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
                               " Active Banner support
                            "   call Decho("active banner handling",'~'.expand("<slnum>"))
                               NetrwKeepj norm! 0
                               let dirname= "./"
                               let curline= getline('.')
                            
                               if curline =~# '"\s*Sorted by\s'
                                NetrwKeepj norm! "_s
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "s" also works'
                            
                               elseif curline =~# '"\s*Sort sequence:'
                                let s:netrw_skipbrowse= 1
                                echo 'Press "S" to edit sorting sequence'
                            
                               elseif curline =~# '"\s*Quick Help:'
                                NetrwKeepj norm! ?
                                let s:netrw_skipbrowse= 1
                            
                               elseif curline =~# '"\s*\%(Hiding\|Showing\):'
                                NetrwKeepj norm! a
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "a" also works'
                            
                               elseif line("$") > w:netrw_bannercnt
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt
                               endif
                            
    4              0.000005   elseif w:netrw_liststyle == s:THINLIST
                            "   call Decho("thin column handling",'~'.expand("<slnum>"))
    4              0.000039    NetrwKeepj norm! 0
    4              0.000024    let dirname= substitute(getline('.'),'\t -->.*$','','')
                            
                              elseif w:netrw_liststyle == s:LONGLIST
                            "   call Decho("long column handling",'~'.expand("<slnum>"))
                               NetrwKeepj norm! 0
                               let dirname= substitute(getline('.'),'^\(\%(\S\+ \)*\S\+\).\{-}$','\1','e')
                            
                              elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "   call Decho("treelist handling",'~'.expand("<slnum>"))
                               let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
                               let dirname= substitute(dirname,'\t -->.*$','','')
                            
                              else
                            "   call Decho("obtain word from wide listing",'~'.expand("<slnum>"))
                               let dirname= getline('.')
                            
                               if !exists("b:netrw_cpf")
                                let b:netrw_cpf= 0
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                call histdel("/",-1)
                            "   "call Decho("computed cpf=".b:netrw_cpf,'~'.expand("<slnum>"))
                               endif
                            
                            "   call Decho("buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                               let filestart = (virtcol(".")/b:netrw_cpf)*b:netrw_cpf
                            "   call Decho("filestart= ([virtcol=".virtcol(".")."]/[b:netrw_cpf=".b:netrw_cpf."])*b:netrw_cpf=".filestart."  bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
                            "   call Decho("1: dirname<".dirname.">",'~'.expand("<slnum>"))
                               if filestart == 0
                                NetrwKeepj norm! 0ma
                               else
                                call cursor(line("."),filestart+1)
                                NetrwKeepj norm! ma
                               endif
                               let rega= @a
                               let eofname= filestart + b:netrw_cpf + 1
                               if eofname <= col("$")
                                call cursor(line("."),filestart+b:netrw_cpf+1)
                                NetrwKeepj norm! "ay`a
                               else
                                NetrwKeepj norm! "ay$
                               endif
                               let dirname = @a
                               let @a      = rega
                            "   call Decho("2: dirname<".dirname.">",'~'.expand("<slnum>"))
                               let dirname= substitute(dirname,'\s\+$','','e')
                            "   call Decho("3: dirname<".dirname.">",'~'.expand("<slnum>"))
    4              0.000001   endif
                            
                              " symlinks are indicated by a trailing "@".  Remove it before further processing.
    4              0.000011   let dirname= substitute(dirname,"@$","","")
                            
                              " executables are indicated by a trailing "*".  Remove it before further processing.
    4              0.000009   let dirname= substitute(dirname,"\*$","","")
                            
    4   0.000016   0.000011   let &l:sol= keepsol
                            
                            "  call Dret("s:NetrwGetWord <".dirname.">")
    4              0.000006   return dirname

FUNCTION  <SNR>53_NetrwOptionsSafe()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:1687
Called 15 times
Total time:   0.054368
 Self time:   0.002065

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionsSafe(islocal=".a:islocal.") win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
                            "  call Decho("win#".winnr()."'s ft=".&ft,'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
   15   0.000312   0.000090   if exists("+acd") | call s:NetrwSetSafeSetting("&l:acd",0)|endif
   15   0.000288   0.000051   call s:NetrwSetSafeSetting("&l:ai",0)
   15   0.000202   0.000053   call s:NetrwSetSafeSetting("&l:aw",0)
   15   0.000175   0.000042   call s:NetrwSetSafeSetting("&l:bl",0)
   15   0.000175   0.000041   call s:NetrwSetSafeSetting("&l:bomb",0)
   15              0.000007   if a:islocal
   15   0.000243   0.000045    call s:NetrwSetSafeSetting("&l:bt","nofile")
                              else
                               call s:NetrwSetSafeSetting("&l:bt","acwrite")
   15              0.000004   endif
   15   0.000185   0.000047   call s:NetrwSetSafeSetting("&l:ci",0)
   15   0.000173   0.000040   call s:NetrwSetSafeSetting("&l:cin",0)
   15              0.000012   if g:netrw_fastbrowse > a:islocal
                               call s:NetrwSetSafeSetting("&l:bh","hide")
   15              0.000004   else
   15   0.000178   0.000043    call s:NetrwSetSafeSetting("&l:bh","delete")
   15              0.000003   endif
   15   0.000176   0.000040   call s:NetrwSetSafeSetting("&l:cino","")
   15   0.000248   0.000041   call s:NetrwSetSafeSetting("&l:com","")
   15   0.000311   0.000109   if &cpo =~ 'a' | call s:NetrwSetSafeSetting("&cpo",substitute(&cpo,'a','','g')) | endif
   15              0.000043   if &cpo =~ 'A' | call s:NetrwSetSafeSetting("&cpo",substitute(&cpo,'A','','g')) | endif
   15   0.000047   0.000041   setl fo=nroql2
   15              0.000029   if &go =~ 'a' | set go-=a | endif
   15              0.000018   if &go =~ 'A' | set go-=A | endif
   15              0.000017   if &go =~ 'P' | set go-=P | endif
   15   0.000230   0.000046   call s:NetrwSetSafeSetting("&l:hid",0)
   15   0.000182   0.000042   call s:NetrwSetSafeSetting("&l:im",0)
   15   0.000542   0.000532   setl isk+=@ isk+=* isk+=/
   15   0.000192   0.000050   call s:NetrwSetSafeSetting("&l:magic",1)
   15              0.000009   if g:netrw_use_noswf
   15   0.000155   0.000040    call s:NetrwSetSafeSetting("swf",0)
   15              0.000004   endif
   15   0.000227   0.000042   call s:NetrwSetSafeSetting("&l:report",10000)
   15   0.000181   0.000044   call s:NetrwSetSafeSetting("&l:sel","inclusive")
   15   0.000183   0.000043   call s:NetrwSetSafeSetting("&l:spell",0)
   15   0.000183   0.000042   call s:NetrwSetSafeSetting("&l:tw",0)
   15   0.000180   0.000044   call s:NetrwSetSafeSetting("&l:wig","")
   15   0.000030   0.000027   setl cedit&
                            
                              " set up cuc and cul based on g:netrw_cursor and listing style
                              " COMBAK -- cuc cul related
   15   0.000420   0.000064   call s:NetrwCursor(0)
                            
                              " allow the user to override safe options
                            "  call Decho("ft<".&ft."> ei=".&ei,'~'.expand("<slnum>"))
   15              0.000011   if &ft == "netrw"
                            "   call Decho("do any netrw FileType autocmds (doau FileType netrw)",'~'.expand("<slnum>"))
   15   0.048663   0.000077    keepalt NetrwKeepj doau FileType netrw
   15              0.000010   endif
                            
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh." bt<".&bt.">",'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionsSafe")

FUNCTION  <SNR>53_NetrwGlob()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:5738
Called 14 times
Total time:   0.001316
 Self time:   0.000808

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwGlob(direntry<".a:direntry."> expr<".a:expr."> pare=".a:pare.")")
   14   0.000161   0.000036   if netrw#CheckIfRemote()
                               keepalt 1sp
                               keepalt enew
                               let keep_liststyle    = w:netrw_liststyle
                               let w:netrw_liststyle = s:THINLIST
                               if s:NetrwRemoteListing() == 0
                                keepj keepalt %s@/@@
                                let filelist= getline(1,$)
                                q!
                               else
                                " remote listing error -- leave treedict unchanged
                                let filelist= w:netrw_treedict[a:direntry]
                               endif
                               let w:netrw_liststyle= keep_liststyle
   14              0.000017   elseif v:version > 704 || (v:version == 704 && has("patch656"))
   14   0.000955   0.000572    let filelist= glob(s:ComposePath(fnameescape(a:direntry),a:expr),0,1,1)
   14              0.000010    if a:pare
                                let filelist= map(filelist,'substitute(v:val, "^.*/", "", "")')
   14              0.000003    endif
                              else
                               let filelist= glob(s:ComposePath(fnameescape(a:direntry),a:expr),0,1)
                               if a:pare
                                let filelist= map(filelist,'substitute(v:val, "^.*/", "", "")')
                               endif
   14              0.000003   endif
                            "  call Dret("s:NetrwGlob ".string(filelist))
   14              0.000008   return filelist

FUNCTION  netrw#UserMaps()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:11468
Called 7 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
                            "  call Dfunc("netrw#UserMaps(islocal=".a:islocal.")")
                            "  call Decho("g:Netrw_UserMaps ".(exists("g:Netrw_UserMaps")? "exists" : "does NOT exist"),'~'.expand("<slnum>"))
                            
                               " set up usermaplist
    7              0.000013    if exists("g:Netrw_UserMaps") && type(g:Netrw_UserMaps) == 3
                            "    call Decho("g:Netrw_UserMaps has type 3<List>",'~'.expand("<slnum>"))
                                for umap in g:Netrw_UserMaps
                            "     call Decho("type(umap[0]<".string(umap[0]).">)=".type(umap[0])." (should be 1=string)",'~'.expand("<slnum>"))
                            "     call Decho("type(umap[1])=".type(umap[1])." (should be 1=string)",'~'.expand("<slnum>"))
                                 " if umap[0] is a string and umap[1] is a string holding a function name
                                 if type(umap[0]) == 1 && type(umap[1]) == 1
                            "      call Decho("nno <buffer> <silent> ".umap[0]." :call s:UserMaps(".a:islocal.",".string(umap[1]).")<cr>",'~'.expand("<slnum>"))
                                  exe "nno <buffer> <silent> ".umap[0]." :call <SID>UserMaps(".a:islocal.",'".umap[1]."')<cr>"
                                  else
                                   call netrw#ErrorMsg(s:WARNING,"ignoring usermap <".string(umap[0])."> -- not a [string,funcref] entry",99)
                                 endif
                                endfor
    7              0.000002    endif
                            "  call Dret("netrw#UserMaps")

FUNCTION  <SNR>53_NetrwSetSafeSetting()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:1885
Called 315 times
Total time:   0.003343
 Self time:   0.003307

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwSetSafeSetting(setting<".a:setting."> safesetting<".a:safesetting.">)")
                            
  315              0.000401   if a:setting =~ '^&'
                            "   call Decho("fyi: a:setting starts with &")
  300              0.000498    exe "let settingval= ".a:setting
                            "   call Decho("fyi: settingval<".settingval.">")
                            
  300              0.000205    if settingval != a:safesetting
                            "    call Decho("set setting<".a:setting."> to option value<".a:safesetting.">")
   83              0.000073     if type(a:safesetting) == 0
   45   0.000158   0.000146      exe "let ".a:setting."=".a:safesetting
   38              0.000030     elseif type(a:safesetting) == 1
   38   0.000172   0.000148      exe "let ".a:setting."= '".a:safesetting."'"
                                else
                                 call netrw#ErrorMsg(s:ERROR,"(s:NetrwRestoreSetting) doesn't know how to restore ".a:setting." with a safesetting of type#".type(a:safesetting),105)
   83              0.000023     endif
  300              0.000069    endif
  315              0.000069   endif
                            
                            "  call Dret("s:NetrwSetSafeSetting")

FUNCTION  <SNR>53_NetrwBookHistHandler()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:3416
Called 7 times
Total time:   0.000594
 Self time:   0.000568

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBookHistHandler(chg=".a:chg." curdir<".a:curdir.">) cnt=".v:count." histcnt=".g:netrw_dirhistcnt." histmax=".g:netrw_dirhistmax)
    7              0.000011   if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   "  call Dret("s:NetrwBookHistHandler - suppressed due to g:netrw_dirhistmax")
                               return
    7              0.000002   endif
                            
    7              0.000009   let ykeep    = @@
    7              0.000008   let curbufnr = bufnr("%")
                            
    7              0.000004   if a:chg == 0
                               " bookmark the current directory
                            "   call Decho("(user: <b>) bookmark the current directory",'~'.expand("<slnum>"))
                               if exists("s:netrwmarkfilelist_{curbufnr}")
                                call s:NetrwBookmark(0)
                                echo "bookmarked marked files"
                               else
                                call s:MakeBookmark(a:curdir)
                                echo "bookmarked the current directory"
                               endif
                            
                               try
                                call s:NetrwBookHistSave()
                               catch
                               endtry
                            
    7              0.000004   elseif a:chg == 1
                               " change to the bookmarked directory
                            "   call Decho("(user: <".v:count."gb>) change to the bookmarked directory",'~'.expand("<slnum>"))
                               if exists("g:netrw_bookmarklist[v:count-1]")
                            "    call Decho("(user: <".v:count."gb>) bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
                                exe "NetrwKeepj e ".fnameescape(g:netrw_bookmarklist[v:count-1])
                               else
                                echomsg "Sorry, bookmark#".v:count." doesn't exist!"
                               endif
                            
    7              0.000003   elseif a:chg == 2
                            "   redraw!
                               let didwork= 0
                               " list user's bookmarks
                            "   call Decho("(user: <q>) list user's bookmarks",'~'.expand("<slnum>"))
                               if exists("g:netrw_bookmarklist")
                            "    call Decho('list '.len(g:netrw_bookmarklist).' bookmarks','~'.expand("<slnum>"))
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                            "     call Decho("Netrw Bookmark#".cnt.": ".g:netrw_bookmarklist[cnt-1],'~'.expand("<slnum>"))
                                 echo printf("Netrw Bookmark#%-2d: %s",cnt,g:netrw_bookmarklist[cnt-1])
                                 let didwork = 1
                                 let cnt     = cnt + 1
                                endfor
                               endif
                            
                               " list directory history
                               " Note: history is saved only when PerformListing is done;
                               "       ie. when netrw can re-use a netrw buffer, the current directory is not saved in the history.
                               let cnt     = g:netrw_dirhistcnt
                               let first   = 1
                               let histcnt = 0
                               if g:netrw_dirhistmax > 0
                                while ( first || cnt != g:netrw_dirhistcnt )
                            "    call Decho("first=".first." cnt=".cnt." dirhistcnt=".g:netrw_dirhistcnt,'~'.expand("<slnum>"))
                                 if exists("g:netrw_dirhist_{cnt}")
                            "     call Decho("Netrw  History#".histcnt.": ".g:netrw_dirhist_{cnt},'~'.expand("<slnum>"))
                                  echo printf("Netrw  History#%-2d: %s",histcnt,g:netrw_dirhist_{cnt})
                                  let didwork= 1
                                 endif
                                 let histcnt = histcnt + 1
                                 let first   = 0
                                 let cnt     = ( cnt - 1 ) % g:netrw_dirhistmax
                                 if cnt < 0
                                  let cnt= cnt + g:netrw_dirhistmax
                                 endif
                                endwhile
                               else
                                let g:netrw_dirhistcnt= 0
                               endif
                               if didwork
                                call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                               endif
                            
    7              0.000004   elseif a:chg == 3
                               " saves most recently visited directories (when they differ)
                            "   call Decho("(browsing) record curdir history",'~'.expand("<slnum>"))
    7              0.000026    if !exists("g:netrw_dirhistcnt") || !exists("g:netrw_dirhist_{g:netrw_dirhistcnt}") || g:netrw_dirhist_{g:netrw_dirhistcnt} != a:curdir
    3              0.000002     if g:netrw_dirhistmax > 0
    3              0.000006      let g:netrw_dirhistcnt                   = ( g:netrw_dirhistcnt + 1 ) % g:netrw_dirhistmax
    3              0.000006      let g:netrw_dirhist_{g:netrw_dirhistcnt} = a:curdir
    3              0.000001     endif
                            "    call Decho("save dirhist#".g:netrw_dirhistcnt."<".g:netrw_dirhist_{g:netrw_dirhistcnt}.">",'~'.expand("<slnum>"))
    7              0.000001    endif
                            
                              elseif a:chg == 4
                               " u: change to the previous directory stored on the history list
                            "   call Decho("(user: <u>) chg to prev dir from history",'~'.expand("<slnum>"))
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhistcnt= ( g:netrw_dirhistcnt - v:count1 ) % g:netrw_dirhistmax
                                if g:netrw_dirhistcnt < 0
                                 let g:netrw_dirhistcnt= g:netrw_dirhistcnt + g:netrw_dirhistmax
                                endif
                               else
                                let g:netrw_dirhistcnt= 0
                               endif
                               if exists("g:netrw_dirhist_{g:netrw_dirhistcnt}")
                            "    call Decho("changedir u#".g:netrw_dirhistcnt."<".g:netrw_dirhist_{g:netrw_dirhistcnt}.">",'~'.expand("<slnum>"))
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                 setl ma noro
                            "     call Decho("setl ma noro",'~'.expand("<slnum>"))
                                 sil! NetrwKeepj %d _
                                 setl nomod
                            "     call Decho("setl nomod",'~'.expand("<slnum>"))
                            "     call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                endif
                            "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhistcnt}),'~'.expand("<slnum>"))
                                exe "NetrwKeepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhistcnt})
                               else
                                if g:netrw_dirhistmax > 0
                                 let g:netrw_dirhistcnt= ( g:netrw_dirhistcnt + v:count1 ) % g:netrw_dirhistmax
                                else
                                 let g:netrw_dirhistcnt= 0
                                endif
                                echo "Sorry, no predecessor directory exists yet"
                               endif
                            
                              elseif a:chg == 5
                               " U: change to the subsequent directory stored on the history list
                            "   call Decho("(user: <U>) chg to next dir from history",'~'.expand("<slnum>"))
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhistcnt= ( g:netrw_dirhistcnt + 1 ) % g:netrw_dirhistmax
                                if exists("g:netrw_dirhist_{g:netrw_dirhistcnt}")
                            "    call Decho("changedir U#".g:netrw_dirhistcnt."<".g:netrw_dirhist_{g:netrw_dirhistcnt}.">",'~'.expand("<slnum>"))
                                 if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                            "      call Decho("setl ma noro",'~'.expand("<slnum>"))
                                  setl ma noro
                                  sil! NetrwKeepj %d _
                            "      call Decho("removed all lines from buffer (%d)",'~'.expand("<slnum>"))
                            "      call Decho("setl nomod",'~'.expand("<slnum>"))
                                  setl nomod
                            "      call Decho("(set nomod)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                 endif
                            "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhistcnt}),'~'.expand("<slnum>"))
                                 exe "NetrwKeepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhistcnt})
                                else
                                 let g:netrw_dirhistcnt= ( g:netrw_dirhistcnt - 1 ) % g:netrw_dirhistmax
                                 if g:netrw_dirhistcnt < 0
                                  let g:netrw_dirhistcnt= g:netrw_dirhistcnt + g:netrw_dirhistmax
                                 endif
                                 echo "Sorry, no successor directory exists yet"
                                endif
                               else
                                let g:netrw_dirhistcnt= 0
                                echo "Sorry, no successor directory exists yet (g:netrw_dirhistmax is ".g:netrw_dirhistmax.")"
                               endif
                            
                              elseif a:chg == 6
                            "   call Decho("(user: <mB>) delete bookmark'd directory",'~'.expand("<slnum>"))
                               if exists("s:netrwmarkfilelist_{curbufnr}")
                                call s:NetrwBookmark(1)
                                echo "removed marked files from bookmarks"
                               else
                                " delete the v:count'th bookmark
                                let iremove = v:count
                                let dremove = g:netrw_bookmarklist[iremove - 1]
                            "    call Decho("delete bookmark#".iremove."<".g:netrw_bookmarklist[iremove - 1].">",'~'.expand("<slnum>"))
                                call s:MergeBookmarks()
                            "    call Decho("remove g:netrw_bookmarklist[".(iremove-1)."]<".g:netrw_bookmarklist[(iremove-1)].">",'~'.expand("<slnum>"))
                                NetrwKeepj call remove(g:netrw_bookmarklist,iremove-1)
                                echo "removed ".dremove." from g:netrw_bookmarklist"
                            "    call Decho("g:netrw_bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
                               endif
                            "   call Decho("resulting g:netrw_bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
                            
                               try
                                call s:NetrwBookHistSave()
                               catch
                               endtry
    7              0.000002   endif
    7   0.000039   0.000025   call s:NetrwBookmarkMenu()
    7   0.000031   0.000020   call s:NetrwTgtMenu()
    7              0.000007   let @@= ykeep
                            "  call Dret("s:NetrwBookHistHandler")

FUNCTION  <SNR>53_NetrwFullPath()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:4146
Called 14 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
                            "  " call Dfunc("s:NetrwFullPath(filename<".a:filename.">)")
   14              0.000015   let filename= a:filename
   14              0.000029   if filename !~ '^/'
                               let filename= resolve(getcwd().'/'.filename)
   14              0.000004   endif
   14              0.000030   if filename != "/" && filename =~ '/$'
   14              0.000043    let filename= substitute(filename,'/$','','')
   14              0.000004   endif
                            "  " call Dret("s:NetrwFullPath <".filename.">")
   14              0.000009   return filename

FUNCTION  <SNR>53_NetrwCommands()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:6724
Called 7 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwCommands(islocal=".a:islocal.")")
                            
    7              0.000035   com! -nargs=* -complete=file -bang	NetrwMB	call s:NetrwBookmark(<bang>0,<f-args>)
    7              0.000014   com! -nargs=*			    	NetrwC	call s:NetrwSetChgwin(<q-args>)
    7              0.000044   com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"win#".winnr()." not a former netrw window",79)|endif
    7              0.000004   if a:islocal
    7              0.000013    com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(1,<f-args>)
                              else
                               com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(0,<f-args>)
    7              0.000002   endif
    7              0.000009   com! -buffer -nargs=? -complete=file	MT	call s:NetrwMarkTarget(<q-args>)
                            
                            "  call Dret("s:NetrwCommands")

FUNCTION  <SNR>53_NetrwMenu()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:8369
Called 8 times
Total time:   0.000609
 Self time:   0.000609

count  total (s)   self (s)
                            
    8              0.000011   if !exists("g:NetrwMenuPriority")
                               let g:NetrwMenuPriority= 80
    8              0.000002   endif
                            
    8              0.000019   if has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                            "   call Dfunc("NetrwMenu(domenu=".a:domenu.")")
                            
                               if !exists("s:netrw_menu_enabled") && a:domenu
                            "    call Decho("initialize menu",'~'.expand("<slnum>"))
                                let s:netrw_menu_enabled= 1
                                exe 'sil! menu '.g:NetrwMenuPriority.'.1      '.g:NetrwTopLvlMenu.'Help<tab><F1>	<F1>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.5      '.g:NetrwTopLvlMenu.'-Sep1-	:'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.6      '.g:NetrwTopLvlMenu.'Go\ Up\ Directory<tab>-	-'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.7      '.g:NetrwTopLvlMenu.'Apply\ Special\ Viewer<tab>x	x'
                                if g:netrw_dirhistmax > 0
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.1   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Current\ Directory<tab>mb	mb'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.4   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Prev\ Dir\ (History)<tab>u	u'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.5   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Next\ Dir\ (History)<tab>U	U'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.6   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.List<tab>qb	qb'
                                else
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8     '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History	:echo "(disabled)"'."\<cr>"
                                endif
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.1    '.g:NetrwTopLvlMenu.'Browsing\ Control.Horizontal\ Split<tab>o	o'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.2    '.g:NetrwTopLvlMenu.'Browsing\ Control.Vertical\ Split<tab>v	v'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.3    '.g:NetrwTopLvlMenu.'Browsing\ Control.New\ Tab<tab>t	t'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.4    '.g:NetrwTopLvlMenu.'Browsing\ Control.Preview<tab>p	p'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.5    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ File\ Hiding\ List<tab><ctrl-h>'."	\<c-h>'"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.6    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ Sorting\ Sequence<tab>S	S'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.7    '.g:NetrwTopLvlMenu.'Browsing\ Control.Quick\ Hide/Unhide\ Dot\ Files<tab>'."gh	gh"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.8    '.g:NetrwTopLvlMenu.'Browsing\ Control.Refresh\ Listing<tab>'."<ctrl-l>	\<c-l>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.9    '.g:NetrwTopLvlMenu.'Browsing\ Control.Settings/Options<tab>:NetrwSettings	'.":NetrwSettings\<cr>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.10     '.g:NetrwTopLvlMenu.'Delete\ File/Directory<tab>D	D'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Create\ New\ File<tab>%	%'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Current\ Window<tab><cr>	'."\<cr>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.2   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Preview\ File/Directory<tab>p	p'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.3   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Previous\ Window<tab>P	P'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.4   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Window<tab>o	o'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Tab<tab>t	t'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Vertical\ Window<tab>v	v'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.1   '.g:NetrwTopLvlMenu.'Explore.Directory\ Name	:Explore '
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (curdir\ only)<tab>:Explore\ */	:Explore */'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (+subdirs)<tab>:Explore\ **/	:Explore **/'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.3   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (curdir\ only)<tab>:Explore\ *//	:Explore *//'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (+subdirs)<tab>:Explore\ **//	:Explore **//'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Next\ Match<tab>:Nexplore	:Nexplore<cr>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Prev\ Match<tab>:Pexplore	:Pexplore<cr>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.13     '.g:NetrwTopLvlMenu.'Make\ Subdirectory<tab>d	d'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.1   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ File<tab>mf	mf'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.2   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ Files\ by\ Regexp<tab>mr	mr'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.3   '.g:NetrwTopLvlMenu.'Marked\ Files.Hide-Show-List\ Control<tab>a	a'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.4   '.g:NetrwTopLvlMenu.'Marked\ Files.Copy\ To\ Target<tab>mc	mc'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.5   '.g:NetrwTopLvlMenu.'Marked\ Files.Delete<tab>D	D'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.6   '.g:NetrwTopLvlMenu.'Marked\ Files.Diff<tab>md	md'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.7   '.g:NetrwTopLvlMenu.'Marked\ Files.Edit<tab>me	me'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.8   '.g:NetrwTopLvlMenu.'Marked\ Files.Exe\ Cmd<tab>mx	mx'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.9   '.g:NetrwTopLvlMenu.'Marked\ Files.Move\ To\ Target<tab>mm	mm'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.10  '.g:NetrwTopLvlMenu.'Marked\ Files.Obtain<tab>O	O'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.11  '.g:NetrwTopLvlMenu.'Marked\ Files.Print<tab>mp	mp'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.12  '.g:NetrwTopLvlMenu.'Marked\ Files.Replace<tab>R	R'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.13  '.g:NetrwTopLvlMenu.'Marked\ Files.Set\ Target<tab>mt	mt'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.14  '.g:NetrwTopLvlMenu.'Marked\ Files.Tag<tab>mT	mT'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.15  '.g:NetrwTopLvlMenu.'Marked\ Files.Zip/Unzip/Compress/Uncompress<tab>mz	mz'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.15     '.g:NetrwTopLvlMenu.'Obtain\ File<tab>O	O'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.thin<tab>i	:let w:netrw_liststyle=0<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.long<tab>i	:let w:netrw_liststyle=1<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.wide<tab>i	:let w:netrw_liststyle=2<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.tree<tab>i	:let w:netrw_liststyle=3<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.1 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Show\ All<tab>a	:let g:netrw_hide=0<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.3 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Normal<tab>a	:let g:netrw_hide=1<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.2 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Hidden\ Only<tab>a	:let g:netrw_hide=2<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.3   '.g:NetrwTopLvlMenu.'Style.Reverse\ Sorting\ Order<tab>'."r	r"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.1 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Name<tab>s       :let g:netrw_sort_by="name"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.2 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Time<tab>s       :let g:netrw_sort_by="time"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Size<tab>s       :let g:netrw_sort_by="size"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Exten<tab>s      :let g:netrw_sort_by="exten"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.17     '.g:NetrwTopLvlMenu.'Rename\ File/Directory<tab>R	R'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.18     '.g:NetrwTopLvlMenu.'Set\ Current\ Directory<tab>c	c'
                                let s:netrw_menucnt= 28
                                call s:NetrwBookmarkMenu() " provide some history!  uses priorities 2,3, reserves 4, 8.2.x
                                call s:NetrwTgtMenu()      " let bookmarks and history be easy targets
                            
                               elseif !a:domenu
                                let s:netrwcnt = 0
                                let curwin     = winnr()
                                windo if getline(2) =~# "Netrw" | let s:netrwcnt= s:netrwcnt + 1 | endif
                                exe curwin."wincmd w"
                            
                                if s:netrwcnt <= 1
                            "     call Decho("clear menus",'~'.expand("<slnum>"))
                                 exe 'sil! unmenu '.g:NetrwTopLvlMenu
                            "     call Decho('exe sil! unmenu '.g:NetrwTopLvlMenu.'*','~'.expand("<slnum>"))
                                 sil! unlet s:netrw_menu_enabled
                                endif
                               endif
                            "   call Dret("NetrwMenu")
                               return
    8              0.000002   endif
                            

FUNCTION  <SNR>53_NetrwOptionsRestore()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:1748
Called 25 times
Total time:   0.033226
 Self time:   0.003224

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionsRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
                            "  call Decho("(s:NetrwOptionsRestore) lines=".&lines)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
   25              0.000045   if !exists("{a:vt}netrw_optionsave")
                            "   call Decho("case ".a:vt."netrw_optionsave : doesn't exist",'~'.expand("<slnum>"))
                            
                               " filereadable() returns zero for remote files (e.g. scp://localhost//etc/fstab)
    7              0.000036    if filereadable(expand("%")) || expand("%") =~# '^\w\+://\f\+/'
                            "    call Decho("..doing filetype detect anyway")
                                filetype detect
                            "    call Decho("..settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
    7              0.000002    else
    7   0.019376   0.000021     setl ft=netrw
    7              0.000004    endif
                            "   call Decho("..ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwOptionsRestore : ".a:vt."netrw_optionsave doesn't exist")
    7              0.000003    return
   18              0.000004   endif
   18              0.000023   unlet {a:vt}netrw_optionsave
                            
   18              0.000018   if exists("+acd")
   18              0.000023    if exists("{a:vt}netrw_acdkeep")
                            "    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
   18              0.000046     let curdir = getcwd()
   18   0.000064   0.000057     let &l:acd = {a:vt}netrw_acdkeep
   18              0.000017     unlet {a:vt}netrw_acdkeep
   18              0.000009     if &l:acd
                                 call s:NetrwLcd(curdir)
   18              0.000005     endif
   18              0.000005    endif
   18              0.000004   endif
                            "  call Decho("(s:NetrwOptionsRestore) #1 lines=".&lines)
   18   0.000442   0.000081   call s:NetrwRestoreSetting(a:vt."netrw_aikeep","&l:ai")
   18   0.000313   0.000071   call s:NetrwRestoreSetting(a:vt."netrw_awkeep","&l:aw")
   18   0.001165   0.000059   call s:NetrwRestoreSetting(a:vt."netrw_blkeep","&l:bl")
   18   0.000406   0.000063   call s:NetrwRestoreSetting(a:vt."netrw_btkeep","&l:bt")
   18   0.000296   0.000062   call s:NetrwRestoreSetting(a:vt."netrw_bombkeep","&l:bomb")
                            "  call Decho("(s:NetrwOptionsRestore) #2 lines=".&lines)
   18   0.000275   0.000055   call s:NetrwRestoreSetting(a:vt."netrw_cedit","&cedit")
   18   0.000275   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_cikeep","&l:ci")
   18   0.000268   0.000055   call s:NetrwRestoreSetting(a:vt."netrw_cinkeep","&l:cin")
   18   0.000276   0.000060   call s:NetrwRestoreSetting(a:vt."netrw_cinokeep","&l:cino")
   18   0.000356   0.000056   call s:NetrwRestoreSetting(a:vt."netrw_comkeep","&l:com")
                            "  call Decho("(s:NetrwOptionsRestore) #3 lines=".&lines)
   18   0.000342   0.000063   call s:NetrwRestoreSetting(a:vt."netrw_cpokeep","&l:cpo")
   18   0.000276   0.000059   call s:NetrwRestoreSetting(a:vt."netrw_diffkeep","&l:diff")
   18   0.000269   0.000058   call s:NetrwRestoreSetting(a:vt."netrw_fenkeep","&l:fen")
   18              0.000021   if exists("g:netrw_ffkeep") && g:netrw_ffkeep
                               call s:NetrwRestoreSetting(a:vt."netrw_ffkeep")","&l:ff")
   18              0.000005   endif
                            "  call Decho("(s:NetrwOptionsRestore) #4 lines=".&lines)
   18   0.000331   0.000056   call s:NetrwRestoreSetting(a:vt."netrw_fokeep"   ,"&l:fo")
   18   0.000270   0.000057   call s:NetrwRestoreSetting(a:vt."netrw_gdkeep"   ,"&l:gd")
   18   0.000275   0.000052   call s:NetrwRestoreSetting(a:vt."netrw_gokeep"   ,"&go")
   18   0.000325   0.000055   call s:NetrwRestoreSetting(a:vt."netrw_hidkeep"  ,"&l:hidden")
                            "  call Decho("(s:NetrwOptionsRestore) #5 lines=".&lines)
   18   0.000264   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_imkeep"   ,"&l:im")
   18   0.000484   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_iskkeep"  ,"&l:isk")
                            "  call Decho("(s:NetrwOptionsRestore) #6 lines=".&lines)
   18   0.000271   0.000057   call s:NetrwRestoreSetting(a:vt."netrw_lines"    ,"&lines")
                            "  call Decho("(s:NetrwOptionsRestore) #7 lines=".&lines)
   18   0.000263   0.000052   call s:NetrwRestoreSetting(a:vt."netrw_lskeep"   ,"&l:ls")
   18   0.000261   0.000052   call s:NetrwRestoreSetting(a:vt."netrw_makeep"   ,"&l:ma")
   18   0.000265   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_magickeep","&l:magic")
   18   0.000316   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_modkeep"  ,"&l:mod")
   18   0.000275   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_nukeep"   ,"&l:nu")
                            "  call Decho("(s:NetrwOptionsRestore) #8 lines=".&lines)
   18   0.000273   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_rnukeep"  ,"&l:rnu")
   18   0.000319   0.000055   call s:NetrwRestoreSetting(a:vt."netrw_repkeep"  ,"&l:report")
   18   0.000264   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_rokeep"   ,"&l:ro")
   18   0.000267   0.000052   call s:NetrwRestoreSetting(a:vt."netrw_selkeep"  ,"&l:sel")
                            "  call Decho("(s:NetrwOptionsRestore) #9 lines=".&lines)
   18   0.000270   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_spellkeep","&l:spell")
   18   0.000268   0.000054   call s:NetrwRestoreSetting(a:vt."netrw_twkeep"   ,"&l:tw")
   18   0.000271   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_wigkeep"  ,"&l:wig")
   18   0.000265   0.000054   call s:NetrwRestoreSetting(a:vt."netrw_wrapkeep" ,"&l:wrap")
   18   0.000264   0.000054   call s:NetrwRestoreSetting(a:vt."netrw_writekeep","&l:write")
                            "  call Decho("(s:NetrwOptionsRestore) #10 lines=".&lines)
   18   0.000270   0.000050   call s:NetrwRestoreSetting("s:yykeep","@@")
                              " former problem: start with liststyle=0; press <i> : result, following line resets l:ts.
                              " Fixed; in s:PerformListing, when w:netrw_liststyle is s:LONGLIST, will use a printf to pad filename with spaces
                              "        rather than by appending a tab which previously was using "&ts" to set the desired spacing.  (Sep 28, 2018)
   18   0.000288   0.000053   call s:NetrwRestoreSetting(a:vt."netrw_tskeep","&l:ts")
                            
   18              0.000026   if exists("{a:vt}netrw_swfkeep")
                               if &directory == ""
                                " user hasn't specified a swapfile directory;
                                " netrw will temporarily set the swapfile directory
                                " to the current directory as returned by getcwd().
                                let &l:directory= getcwd()
                                sil! let &l:swf = {a:vt}netrw_swfkeep
                                setl directory=
                                unlet {a:vt}netrw_swfkeep
                               elseif &l:swf != {a:vt}netrw_swfkeep
                                if !g:netrw_use_noswf
                                 " following line causes a Press ENTER in windows -- can't seem to work around it!!!
                                 sil! let &l:swf= {a:vt}netrw_swfkeep
                                endif
                                unlet {a:vt}netrw_swfkeep
                               endif
   18              0.000004   endif
   18   0.000504   0.000148   if exists("{a:vt}netrw_dirkeep") && isdirectory(s:NetrwFile({a:vt}netrw_dirkeep)) && g:netrw_keepdir
   18              0.000046    let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
   18              0.000024    if exists("{a:vt}netrw_dirkeep")
   18   0.000522   0.000061     call s:NetrwLcd(dirkeep)
   18              0.000022     unlet {a:vt}netrw_dirkeep
   18              0.000005    endif
   18              0.000004   endif
   18   0.000338   0.000066   call s:NetrwRestoreSetting(a:vt."netrw_slashkeep","@/")
                            
                            "  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ts=".&l:ts,'~'.expand("<slnum>"))
                              " Moved the filetype detect here from NetrwGetFile() because remote files
                              " were having their filetype detect-generated settings overwritten by
                              " NetrwOptionRestore.
   18              0.000016   if &ft != "netrw"
                            "   call Decho("before: filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
                               filetype detect
                            "   call Decho("after : filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
   18              0.000004   endif
                            "  call Decho("(s:NetrwOptionsRestore) lines=".&lines)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionsRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)

FUNCTION  <SNR>29_dopopd()
    Defined: /usr/share/vim/vimfiles/plugin/fzf.vim:618
Called 4 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    4              0.000007   if !exists('w:fzf_pushd')
    4              0.000002     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  <SNR>53_SetRexDir()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:12440
Called 11 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
                            "  call Dfunc("s:SetRexDir(islocal=".a:islocal." dirname<".a:dirname.">) win#".winnr())
   11              0.000014   let w:netrw_rexdir         = a:dirname
   11              0.000009   let w:netrw_rexlocal       = a:islocal
   11              0.000050   let s:rexposn_{bufnr("%")} = winsaveview()
                            "  call Decho("setting w:netrw_rexdir  =".w:netrw_rexdir,'~'.expand("<slnum>"))
                            "  call Decho("setting w:netrw_rexlocal=".w:netrw_rexlocal,'~'.expand("<slnum>"))
                            "  call Decho("saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
                            "  call Decho("setting s:rexposn_".bufnr("%")."<".bufname("%")."> to ".string(winsaveview()),'~'.expand("<slnum>"))
                            "  call Dret("s:SetRexDir : win#".winnr()." ".(a:islocal? "local" : "remote")." dir: ".a:dirname)

FUNCTION  <SNR>53_NetrwSetSort()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:9002
Called 7 times
Total time:   0.003570
 Self time:   0.003570

count  total (s)   self (s)
                            "  call Dfunc("SetSort() bannercnt=".w:netrw_bannercnt)
    7              0.000007   let ykeep= @@
    7              0.000004   if w:netrw_liststyle == s:LONGLIST
                               let seqlist  = substitute(g:netrw_sort_sequence,'\$','\\%(\t\\|\$\\)','ge')
    7              0.000002   else
    7              0.000005    let seqlist  = g:netrw_sort_sequence
    7              0.000002   endif
                              " sanity check -- insure that * appears somewhere
    7              0.000004   if seqlist == ""
                               let seqlist= '*'
    7              0.000008   elseif seqlist !~ '\*'
                               let seqlist= seqlist.',*'
    7              0.000002   endif
    7              0.000004   let priority = 1
   98              0.000046   while seqlist != ""
   91              0.000081    if seqlist =~ ','
   84              0.000273     let seq     = substitute(seqlist,',.*$','','e')
   84              0.000437     let seqlist = substitute(seqlist,'^.\{-},\(.*\)$','\1','e')
    7              0.000001    else
    7              0.000004     let seq     = seqlist
    7              0.000003     let seqlist = ""
   91              0.000017    endif
   91              0.000037    if priority < 10
   63              0.000059     let spriority= "00".priority.g:netrw_sepchr
   28              0.000011    elseif priority < 100
   28              0.000023     let spriority= "0".priority.g:netrw_sepchr
                               else
                                let spriority= priority.g:netrw_sepchr
   91              0.000016    endif
                            "   call Decho("priority=".priority." spriority<".spriority."> seq<".seq."> seqlist<".seqlist.">",'~'.expand("<slnum>"))
                            
                               " sanity check
   91              0.000060    if w:netrw_bannercnt > line("$")
                                " apparently no files were left after a Hiding pattern was used
                            "    call Dret("SetSort : no files left after hiding")
                                return
   91              0.000015    endif
   91              0.000038    if seq == '*'
    7              0.000005     let starpriority= spriority
   84              0.000016    else
   84              0.000746     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/'.seq.'/s/^/'.spriority.'/'
   84              0.000074     call histdel("/",-1)
                                " sometimes multiple sorting patterns will match the same file or directory.
                                " The following substitute is intended to remove the excess matches.
   84              0.000650     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^\d\{3}'.g:netrw_sepchr.'\d\{3}\//s/^\d\{3}'.g:netrw_sepchr.'\(\d\{3}\/\).\@=/\1/e'
   84              0.000123     NetrwKeepj call histdel("/",-1)
   91              0.000020    endif
   91              0.000059    let priority = priority + 1
   98              0.000035   endwhile
    7              0.000007   if exists("starpriority")
    7              0.000066    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/e'
    7              0.000012    NetrwKeepj call histdel("/",-1)
    7              0.000002   endif
                            
                              " Following line associated with priority -- items that satisfy a priority
                              " pattern get prefixed by ###/ which permits easy sorting by priority.
                              " Sometimes files can satisfy multiple priority patterns -- only the latest
                              " priority pattern needs to be retained.  So, at this point, these excess
                              " priority prefixes need to be removed, but not directories that happen to
                              " be just digits themselves.
    7              0.000078   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\d\{3}'.g:netrw_sepchr.'\)\%(\d\{3}'.g:netrw_sepchr.'\)\+\ze./\1/e'
    7              0.000011   NetrwKeepj call histdel("/",-1)
    7              0.000007   let @@= ykeep
                            
                            "  call Dret("SetSort")

FUNCTION  <SNR>53_PerformListing()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:9739
Called 7 times
Total time:   0.061742
 Self time:   0.001616

count  total (s)   self (s)
                            "  call Dfunc("s:PerformListing(islocal=".a:islocal.")")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                            "  call Decho("settings: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (enter)"." ei<".&ei.">",'~'.expand("<slnum>"))
    7              0.000017   sil! NetrwKeepj %d _
                            "  call DechoBuf(bufnr("%"))
                            
                              " set up syntax highlighting {{{3
                            "  call Decho("--set up syntax highlighting (ie. setl ft=netrw)",'~'.expand("<slnum>"))
    7   0.021541   0.000029   sil! setl ft=netrw
                            
    7   0.022055   0.000052   NetrwKeepj call s:NetrwOptionsSafe(a:islocal)
    7   0.000029   0.000021   setl noro ma
                            "  call Decho("setl noro ma bh=".&bh,'~'.expand("<slnum>"))
                            
                            "  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
                            "   call Decho("Processing your browsing request...",'~'.expand("<slnum>"))
                            "  endif								" Decho
                            
                            "  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
    7              0.000019   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " force a refresh for tree listings
                            "   call Decho("force refresh for treelisting: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                               sil! NetrwKeepj %d _
    7              0.000002   endif
                            
                              " save current directory on directory history list
    7   0.000645   0.000051   NetrwKeepj call s:NetrwBookHistHandler(3,b:netrw_curdir)
                            
                              " Set up the banner {{{3
    7              0.000004   if g:netrw_banner
                            "   call Decho("--set up banner",'~'.expand("<slnum>"))
    7              0.000042    NetrwKeepj call setline(1,'" ============================================================================')
    7              0.000006    if exists("g:netrw_pchk")
                                " this undocumented option allows pchk to run with different versions of netrw without causing spurious
                                " failure detections.
                                NetrwKeepj call setline(2,'" Netrw Directory Listing')
    7              0.000002    else
    7              0.000037     NetrwKeepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
    7              0.000002    endif
    7              0.000005    if exists("g:netrw_pchk")
                                let curdir= substitute(b:netrw_curdir,expand("$HOME"),'~','')
    7              0.000002    else
    7              0.000006     let curdir= b:netrw_curdir
    7              0.000001    endif
    7              0.000007    if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
                                NetrwKeepj call setline(3,'"   '.substitute(curdir,'/','\\','g'))
    7              0.000001    else
    7              0.000016     NetrwKeepj call setline(3,'"   '.curdir)
    7              0.000002    endif
    7              0.000005    let w:netrw_bannercnt= 3
    7              0.000027    NetrwKeepj exe "sil! NetrwKeepj ".w:netrw_bannercnt
                              else
                            "   call Decho("--no banner",'~'.expand("<slnum>"))
                               NetrwKeepj 1
                               let w:netrw_bannercnt= 1
    7              0.000002   endif
                            "  call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." win#".winnr(),'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                            
                              " construct sortby string: [name|time|size|exten] [reversed]
    7              0.000005   let sortby= g:netrw_sort_by
    7              0.000016   if g:netrw_sort_direction =~# "^r"
                               let sortby= sortby." reversed"
    7              0.000002   endif
                            
                              " Sorted by... {{{3
    7              0.000003   if g:netrw_banner
                            "   call Decho("--handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))
    7              0.000009    if g:netrw_sort_by =~# "^n"
                            "   call Decho("directories will be sorted by name",'~'.expand("<slnum>"))
                                " sorted by name (also includes the sorting sequence in the banner)
    7              0.000030     NetrwKeepj put ='\"   Sorted by      '.sortby
    7              0.000018     NetrwKeepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
    7              0.000007     let w:netrw_bannercnt= w:netrw_bannercnt + 2
                               else
                            "   call Decho("directories will be sorted by size or time",'~'.expand("<slnum>"))
                                " sorted by time, size, exten
                                NetrwKeepj put ='\"   Sorted by '.sortby
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
    7              0.000002    endif
    7              0.000014    exe "sil! NetrwKeepj ".w:netrw_bannercnt
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
    7              0.000002   endif
                            
                              " show copy/move target, if any {{{3
    7              0.000003   if g:netrw_banner
    7              0.000007    if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
                            "    call Decho("--show copy/move target<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                                NetrwKeepj put =''
                                if s:netrwmftgt_islocal
                                 sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
                                else
                                 sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (remote)')
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
    7              0.000002    else
                            "    call Decho("s:netrwmftgt does not exist, don't make Copy/Move Tgt",'~'.expand("<slnum>"))
    7              0.000001    endif
    7              0.000011    exe "sil! NetrwKeepj ".w:netrw_bannercnt
    7              0.000001   endif
                            
                              " Hiding...  -or-  Showing... {{{3
    7              0.000003   if g:netrw_banner
                            "   call Decho("--handle hiding/showing in banner (g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">)",'~'.expand("<slnum>"))
    7              0.000006    if g:netrw_list_hide != "" && g:netrw_hide
                                if g:netrw_hide == 1
                                 NetrwKeepj put ='\"   Hiding:        '.g:netrw_list_hide
                                else
                                 NetrwKeepj put ='\"   Showing:       '.g:netrw_list_hide
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
    7              0.000002    endif
    7              0.000011    exe "NetrwKeepj ".w:netrw_bannercnt
                            
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
    7              0.000015    let quickhelp   = g:netrw_quickhelp%len(s:QuickHelp)
                            "   call Decho("quickhelp   =".quickhelp,'~'.expand("<slnum>"))
    7              0.000020    NetrwKeepj put ='\"   Quick Help: <F1>:help  '.s:QuickHelp[quickhelp]
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
    7              0.000017    NetrwKeepj put ='\" =============================================================================='
    7              0.000006    let w:netrw_bannercnt= w:netrw_bannercnt + 2
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
    7              0.000002   endif
                            
                              " bannercnt should index the line just after the banner
    7              0.000003   if g:netrw_banner
    7              0.000004    let w:netrw_bannercnt= w:netrw_bannercnt + 1
    7              0.000012    exe "sil! NetrwKeepj ".w:netrw_bannercnt
                            "   call Decho("--w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"),'~'.expand("<slnum>"))
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
    7              0.000001   endif
                            
                              " get list of files
                            "  call Decho("--Get list of files - islocal=".a:islocal,'~'.expand("<slnum>"))
    7              0.000003   if a:islocal
    7   0.005822   0.000033    NetrwKeepj call s:LocalListing()
                              else " remote
                               NetrwKeepj let badresult= s:NetrwRemoteListing()
                               if badresult
                            "    call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            "    call Dret("s:PerformListing : error detected by NetrwRemoteListing")
                                return
                               endif
    7              0.000001   endif
                            
                              " manipulate the directory listing (hide, sort) {{{3
    7              0.000007   if !exists("w:netrw_bannercnt")
                               let w:netrw_bannercnt= 0
    7              0.000001   endif
                            "  call Decho("--manipulate directory listing (hide, sort)",'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)",'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
    7              0.000009   if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "   call Decho("manipulate directory listing (support hide)",'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
    7              0.000007    if g:netrw_hide && g:netrw_list_hide != ""
                                NetrwKeepj call s:NetrwListHide()
    7              0.000002    endif
    7              0.000006    if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "    call Decho("manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))
                            
    7              0.000013     if g:netrw_sort_by =~# "^n"
                                 " sort by name
                            "     call Decho("sort by name",'~'.expand("<slnum>"))
    7   0.003602   0.000033      NetrwKeepj call s:NetrwSetSort()
                            
    7              0.000009      if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
    7              0.000010       if g:netrw_sort_direction =~# 'n'
                                   " name: sort by name of file
    7              0.000050        exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                                   " reverse direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
    7              0.000002       endif
    7              0.000002      endif
                            
                                 " remove priority pattern prefix
                            "     call Decho("remove priority pattern prefix",'~'.expand("<slnum>"))
    7              0.000087      exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
    7              0.000012      NetrwKeepj call histdel("/",-1)
                            
                                elseif g:netrw_sort_by =~# "^ext"
                                 " exten: sort by extension
                                 "   The histdel(...,-1) calls remove the last search from the search history
                            "     call Decho("sort by extension",'~'.expand("<slnum>"))
                                 exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g+/+s/^/001'.g:netrw_sepchr.'/'
                                 NetrwKeepj call histdel("/",-1)
                                 exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+[./]+s/^/002'.g:netrw_sepchr.'/'
                                 NetrwKeepj call histdel("/",-1)
                                 exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+['.g:netrw_sepchr.'/]+s/^\(.*\.\)\(.\{-\}\)$/\2'.g:netrw_sepchr.'&/e'
                                 NetrwKeepj call histdel("/",-1)
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                                  if g:netrw_sort_direction =~# 'n'
                                   " normal direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                                   " reverse direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                                 endif
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^.\{-}'.g:netrw_sepchr.'//e'
                                 NetrwKeepj call histdel("/",-1)
                            
                                elseif a:islocal
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction,'~'.expand("<slnum>"))
                                  if g:netrw_sort_direction =~# 'n'
                            "       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort','~'.expand("<slnum>"))
                                   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                            "       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort!','~'.expand("<slnum>"))
                                   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                            "     call Decho("remove leading digits/ (sorting) information from listing",'~'.expand("<slnum>"))
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{-}\///e'
                                 NetrwKeepj call histdel("/",-1)
                                 endif
    7              0.000002     endif
                            
                               elseif g:netrw_sort_direction =~# 'r'
                            "    call Decho('(s:PerformListing) reverse the sorted listing','~'.expand("<slnum>"))
                                if !g:netrw_banner || w:netrw_bannercnt < line('$')
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
                                 call histdel("/",-1)
                                endif
    7              0.000001    endif
    7              0.000001   endif
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                              " convert to wide/tree listing {{{3
                            "  call Decho("--modify display if wide/tree listing style",'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#1)",'~'.expand("<slnum>"))
    7   0.000322   0.000032   NetrwKeepj call s:NetrwWideListing()
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#2)",'~'.expand("<slnum>"))
    7   0.000182   0.000034   NetrwKeepj call s:NetrwTreeListing(b:netrw_curdir)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#3)",'~'.expand("<slnum>"))
                            
                              " resolve symbolic links if local and (thin or tree)
    7              0.000010   if a:islocal && (w:netrw_liststyle == s:THINLIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST))
                            "   call Decho("--resolve symbolic links if local and thin|tree",'~'.expand("<slnum>"))
    7              0.000032    sil! g/@$/call s:ShowLink()
    7              0.000002   endif
                            
    7              0.000011   if exists("w:netrw_bannercnt") && (line("$") >= w:netrw_bannercnt || !g:netrw_banner)
                               " place cursor on the top-left corner of the file listing
                            "   call Decho("--place cursor on top-left corner of file listing",'~'.expand("<slnum>"))
    7              0.000012    exe 'sil! '.w:netrw_bannercnt
    7              0.000053    sil! NetrwKeepj norm! 0
                            "   call Decho("  tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                              else
                            "   call Decho("--did NOT place cursor on top-left corner",'~'.expand("<slnum>"))
                            "   call Decho("  w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a'),'~'.expand("<slnum>"))
                            "   call Decho("  line($)=".line("$"),'~'.expand("<slnum>"))
                            "   call Decho("  g:netrw_banner=".(exists("g:netrw_banner")? g:netrw_banner : 'n/a'),'~'.expand("<slnum>"))
    7              0.000002   endif
                            
                              " record previous current directory
    7              0.000007   let w:netrw_prvdir= b:netrw_curdir
                            "  call Decho("--record netrw_prvdir<".w:netrw_prvdir.">",'~'.expand("<slnum>"))
                            
                              " save certain window-oriented variables into buffer-oriented variables {{{3
                            "  call Decho("--save some window-oriented variables into buffer oriented variables",'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#4)",'~'.expand("<slnum>"))
    7   0.000143   0.000028   NetrwKeepj call s:SetBufWinVars()
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#5)",'~'.expand("<slnum>"))
    7   0.005498   0.000026   NetrwKeepj call s:NetrwOptionsRestore("w:")
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#6)",'~'.expand("<slnum>"))
                            
                              " set display to netrw display settings
                            "  call Decho("--set display to netrw display settings (".g:netrw_bufsettings.")",'~'.expand("<slnum>"))
    7   0.000675   0.000052   exe "setl ".g:netrw_bufsettings
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#7)",'~'.expand("<slnum>"))
    7              0.000009   if g:netrw_liststyle == s:LONGLIST
                            "   call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
                               exe "setl ts=".(g:netrw_maxfilenamelen+1)
    7              0.000002   endif
                            "  call Decho("PerformListing buffer:",'~'.expand("<slnum>"))
                            "  call DechoBuf(bufnr("%"))
                            
    7              0.000007   if exists("s:treecurpos")
                            "   call Decho("s:treecurpos exists; restore posn",'~'.expand("<slnum>"))
                            "   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#8)",'~'.expand("<slnum>"))
                            "   call Decho("restoring posn to s:treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(s:treecurpos)
                               unlet s:treecurpos
    7              0.000002   endif
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (return)",'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                            "  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")

FUNCTION  <SNR>53_UseBufWinVars()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:12617
Called 11 times
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
                            "  call Dfunc("s:UseBufWinVars()")
   11              0.000049   if exists("b:netrw_liststyle")       && !exists("w:netrw_liststyle")      |let w:netrw_liststyle       = b:netrw_liststyle      |endif
   11              0.000030   if exists("b:netrw_bannercnt")       && !exists("w:netrw_bannercnt")      |let w:netrw_bannercnt       = b:netrw_bannercnt      |endif
   11              0.000024   if exists("b:netrw_method")          && !exists("w:netrw_method")         |let w:netrw_method          = b:netrw_method         |endif
   11              0.000028   if exists("b:netrw_prvdir")          && !exists("w:netrw_prvdir")         |let w:netrw_prvdir          = b:netrw_prvdir         |endif
   11              0.000024   if exists("b:netrw_explore_indx")    && !exists("w:netrw_explore_indx")   |let w:netrw_explore_indx    = b:netrw_explore_indx   |endif
   11              0.000024   if exists("b:netrw_explore_listlen") && !exists("w:netrw_explore_listlen")|let w:netrw_explore_listlen = b:netrw_explore_listlen|endif
   11              0.000023   if exists("b:netrw_explore_mtchcnt") && !exists("w:netrw_explore_mtchcnt")|let w:netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
   11              0.000023   if exists("b:netrw_explore_bufnr")   && !exists("w:netrw_explore_bufnr")  |let w:netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
   11              0.000022   if exists("b:netrw_explore_line")    && !exists("w:netrw_explore_line")   |let w:netrw_explore_line    = b:netrw_explore_line   |endif
   11              0.000022   if exists("b:netrw_explore_list")    && !exists("w:netrw_explore_list")   |let w:netrw_explore_list    = b:netrw_explore_list   |endif
                            "  call Dret("s:UseBufWinVars")

FUNCTION  <SNR>17_LocalBrowse()
    Defined: /usr/share/nvim/runtime/plugin/netrwPlugin.vim:105
Called 8 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    8              0.000013   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    8              0.000003   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    8              0.000016   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    8              0.000023   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    8              0.000002   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    8              0.000002   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  <SNR>53_LocalListing()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:10954
Called 7 times
Total time:   0.005789
 Self time:   0.003400

count  total (s)   self (s)
                            "  call Dfunc("s:LocalListing()")
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Decho("modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            
                            "  if exists("b:netrw_curdir") |call Decho('b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("b:netrw_curdir doesn't exist",'~'.expand("<slnum>")) |endif
                            "  if exists("g:netrw_sort_by")|call Decho('g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("g:netrw_sort_by doesn't exist",'~'.expand("<slnum>"))|endif
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                              " get the list of files contained in the current directory
    7              0.000006   let dirname    = b:netrw_curdir
    7              0.000009   let dirnamelen = strlen(b:netrw_curdir)
    7   0.000812   0.000030   let filelist   = s:NetrwGlob(dirname,"*",0)
    7   0.000570   0.000036   let filelist   = filelist + s:NetrwGlob(dirname,".*",0)
                            "  call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
                            
    7              0.000012   if g:netrw_cygwin == 0 && has("win32")
                            "   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
    7              0.000019   elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
                                " include ../ in the glob() entry if its missing
                            "   call Decho("forcibly including on \"..\"",'~'.expand("<slnum>"))
                               let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
                            "   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
    7              0.000002   endif
                            
                            "  call Decho("before while: dirname   <".dirname.">",'~'.expand("<slnum>"))
                            "  call Decho("before while: dirnamelen<".dirnamelen.">",'~'.expand("<slnum>"))
                            "  call Decho("before while: filelist  =".string(filelist),'~'.expand("<slnum>"))
                            
    7              0.000009   if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
                               let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
                               let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
                            "   call Decho("dynamic_maxfilenamelen: filenames             =".string(filelistcopy),'~'.expand("<slnum>"))
                            "   call Decho("dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen,'~'.expand("<slnum>"))
    7              0.000001   endif
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
   75              0.000034   for filename in filelist
                            "   call Decho(" ",'~'.expand("<slnum>"))
                            "   call Decho("for filename in filelist: filename<".filename.">",'~'.expand("<slnum>"))
                            
   68              0.000156    if getftype(filename) == "link"
                                " indicate a symbolic link
                            "    call Decho("indicate <".filename."> is a symbolic link with trailing @",'~'.expand("<slnum>"))
                                let pfile= filename."@"
                            
   68              0.000136    elseif getftype(filename) == "socket"
                                " indicate a socket
                            "    call Decho("indicate <".filename."> is a socket with trailing =",'~'.expand("<slnum>"))
                                let pfile= filename."="
                            
   68              0.000131    elseif getftype(filename) == "fifo"
                                " indicate a fifo
                            "    call Decho("indicate <".filename."> is a fifo with trailing |",'~'.expand("<slnum>"))
                                let pfile= filename."|"
                            
   68   0.001321   0.000267    elseif isdirectory(s:NetrwFile(filename))
                                " indicate a directory
                            "    call Decho("indicate <".filename."> is a directory with trailing /",'~'.expand("<slnum>"))
   67              0.000047     let pfile= filename."/"
                            
    1   0.000022   0.000007    elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(s:NetrwFile(filename))
    1              0.000001     if has("win32")
                                 if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
                                  " indicate an executable
                            "      call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
                                  let pfile= filename."*"
                                 else
                                  " normal file
                                  let pfile= filename
                                 endif
    1              0.000004     elseif executable(filename)
                                 " indicate an executable
                            "     call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
                                 let pfile= filename."*"
    1              0.000000     else
                                 " normal file
    1              0.000001      let pfile= filename
    1              0.000000     endif
                            
                               else
                                " normal file
                                let pfile= filename
   68              0.000020    endif
                            "   call Decho("pfile<".pfile."> (after *@/ appending)",'~'.expand("<slnum>"))
                            
   68              0.000090    if pfile =~ '//$'
                                let pfile= substitute(pfile,'//$','/','e')
                            "    call Decho("change // to /: pfile<".pfile.">",'~'.expand("<slnum>"))
   68              0.000012    endif
   68              0.000062    let pfile= strpart(pfile,dirnamelen)
   68              0.000119    let pfile= substitute(pfile,'^[/\\]','','e')
                            "   call Decho("filename<".filename.">",'~'.expand("<slnum>"))
                            "   call Decho("pfile   <".pfile.">",'~'.expand("<slnum>"))
                            
   68              0.000038    if w:netrw_liststyle == s:LONGLIST
                                let longfile = printf("%-".g:netrw_maxfilenamelen."S",pfile)
                                let sz       = getfsize(filename)
                                let szlen    = 15 - (strdisplaywidth(longfile) - g:netrw_maxfilenamelen)
                                let szlen    = (szlen > 0) ? szlen : 0
                            
                                if g:netrw_sizestyle =~# "[hH]"
                                 let sz= s:NetrwHumanReadable(sz)
                                endif
                                let fsz  = printf("%".szlen."S",sz)
                                let pfile= longfile."  ".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
                            "    call Decho("longlist support: sz=".sz." fsz=".fsz,'~'.expand("<slnum>"))
   68              0.000012    endif
                            
   68              0.000057    if     g:netrw_sort_by =~# "^t"
                                " sort by time (handles time up to 1 quintillion seconds, US)
                                " Decorate listing by prepending a timestamp/  .  Sorting will then be done based on time.
                            "    call Decho("implementing g:netrw_sort_by=".g:netrw_sort_by." (time)")
                            "    call Decho("getftime(".filename.")=".getftime(filename),'~'.expand("<slnum>"))
                                let t  = getftime(filename)
                                let ft = printf("%018d",t)
                            "    call Decho("exe NetrwKeepj put ='".ft.'/'.pfile."'",'~'.expand("<slnum>"))
                                let ftpfile= ft.'/'.pfile
                                sil! NetrwKeepj put=ftpfile
                            
   68              0.000053    elseif g:netrw_sort_by =~ "^s"
                                " sort by size (handles file sizes up to 1 quintillion bytes, US)
                            "    call Decho("implementing g:netrw_sort_by=".g:netrw_sort_by." (size)")
                            "    call Decho("getfsize(".filename.")=".getfsize(filename),'~'.expand("<slnum>"))
                                let sz   = getfsize(filename)
                                let fsz  = printf("%018d",sz)
                            "    call Decho("exe NetrwKeepj put ='".fsz.'/'.filename."'",'~'.expand("<slnum>"))
                                let fszpfile= fsz.'/'.pfile
                                sil! NetrwKeepj put =fszpfile
                            
   68              0.000014    else
                                " sort by name
                            "    call Decho("implementing g:netrw_sort_by=".g:netrw_sort_by." (name)")
                            "    call Decho("exe NetrwKeepj put ='".pfile."'",'~'.expand("<slnum>"))
   68              0.000148     sil! NetrwKeepj put=pfile
   68              0.000015    endif
                            "   call DechoBuf(bufnr("%"),"bufnr(%)")
   75              0.000029   endfor
                            
                              " cleanup any windows mess at end-of-line
    7              0.000089   sil! NetrwKeepj g/^$/d
    7              0.000032   sil! NetrwKeepj %s/\r$//e
    7              0.000015   call histdel("/",-1)
                            "  call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
    7   0.000031   0.000027   exe "setl ts=".(g:netrw_maxfilenamelen+1)
                            
                            "  call Dret("s:LocalListing")

FUNCTION  <SNR>53_ComposePath()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:11541
Called 19 times
Total time:   0.000556
 Self time:   0.000556

count  total (s)   self (s)
                            "  call Dfunc("s:ComposePath(base<".a:base."> subdir<".a:subdir.">)")
                            
   19              0.000029   if has("amiga")
                            "   call Decho("amiga",'~'.expand("<slnum>"))
                               let ec = a:base[s:Strlen(a:base)-1]
                               if ec != '/' && ec != ':'
                                let ret = a:base."/" . a:subdir
                               else
                                let ret = a:base.a:subdir
                               endif
                            
                               " COMBAK: test on windows with changing to root directory: :e C:/
   19              0.000058   elseif a:subdir =~ '^\a:[/\\]\([^/\\]\|$\)' && has("win32")
                            "   call Decho("windows",'~'.expand("<slnum>"))
                               let ret= a:subdir
                            
   19              0.000038   elseif a:base =~ '^\a:[/\\]\([^/\\]\|$\)' && has("win32")
                            "   call Decho("windows",'~'.expand("<slnum>"))
                               if a:base =~ '[/\\]$'
                                let ret= a:base.a:subdir
                               else
                                let ret= a:base.'/'.a:subdir
                               endif
                            
   19              0.000030   elseif a:base =~ '^\a\{3,}://'
                            "   call Decho("remote linux/macos",'~'.expand("<slnum>"))
                               let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
                               let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
                               if a:subdir == '../'
                                if curpath =~ '[^/]/[^/]\+/$'
                                 let curpath= substitute(curpath,'[^/]\+/$','','')
                                else
                                 let curpath=""
                                endif
                                let ret= urlbase.curpath
                               else
                                let ret= urlbase.curpath.a:subdir
                               endif
                            "   call Decho("urlbase<".urlbase.">",'~'.expand("<slnum>"))
                            "   call Decho("curpath<".curpath.">",'~'.expand("<slnum>"))
                            "   call Decho("ret<".ret.">",'~'.expand("<slnum>"))
                            
   19              0.000004   else
                            "   call Decho("local linux/macos",'~'.expand("<slnum>"))
   19              0.000051    let ret = substitute(a:base."/".a:subdir,"//","/","g")
   19              0.000027    if a:base =~ '^//'
                                " keeping initial '//' for the benefit of network share listing support
                                let ret= '/'.ret
   19              0.000005    endif
   19              0.000025    let ret= simplify(ret)
   19              0.000005   endif
                            
                            "  call Dret("s:ComposePath ".ret)
   19              0.000010   return ret

FUNCTION  <SNR>53_RestorePosn()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:12373
Called 8 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
                            "  call Dfunc("s:RestorePosn(posndict) curbuf#".bufnr("%")."<".bufname("%").">")
    8              0.000012   if exists("a:posndict")
    8              0.000016    if has_key(a:posndict,bufnr("%"))
                            "    call Decho("before pop: a:posndict[buf#".bufnr("%")."]=".string(a:posndict[bufnr('%')]))
    7              0.000019     let posnlen= len(a:posndict[bufnr("%")])
    7              0.000006     if posnlen > 0
    7              0.000008      let posnlen= posnlen - 1
                            "     call Decho("restoring posn posndict[".bufnr("%")."][".posnlen."]=".string(a:posndict[bufnr("%")][posnlen]),'~'.expand("<slnum>"))
    7              0.000025      call winrestview(a:posndict[bufnr("%")][posnlen])
    7              0.000019      call remove(a:posndict[bufnr("%")],posnlen)
                            "     call Decho("after  pop: a:posndict[buf#".bufnr("%")."]=".string(a:posndict[bufnr('%')]))
    7              0.000002     endif
    8              0.000002    endif
    8              0.000002   endif
                            "  call Dret("s:RestorePosn")

FUNCTION  <SNR>53_SetBufWinVars()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:12423
Called 7 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
                            "  call Dfunc("s:SetBufWinVars() win#".winnr())
    7              0.000016   if exists("w:netrw_liststyle")      |let b:netrw_liststyle      = w:netrw_liststyle      |endif
    7              0.000011   if exists("w:netrw_bannercnt")      |let b:netrw_bannercnt      = w:netrw_bannercnt      |endif
    7              0.000010   if exists("w:netrw_method")         |let b:netrw_method         = w:netrw_method         |endif
    7              0.000012   if exists("w:netrw_prvdir")         |let b:netrw_prvdir         = w:netrw_prvdir         |endif
    7              0.000010   if exists("w:netrw_explore_indx")   |let b:netrw_explore_indx   = w:netrw_explore_indx   |endif
    7              0.000010   if exists("w:netrw_explore_listlen")|let b:netrw_explore_listlen= w:netrw_explore_listlen|endif
    7              0.000010   if exists("w:netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt= w:netrw_explore_mtchcnt|endif
    7              0.000009   if exists("w:netrw_explore_bufnr")  |let b:netrw_explore_bufnr  = w:netrw_explore_bufnr  |endif
    7              0.000009   if exists("w:netrw_explore_line")   |let b:netrw_explore_line   = w:netrw_explore_line   |endif
    7              0.000009   if exists("w:netrw_explore_list")   |let b:netrw_explore_list   = w:netrw_explore_list   |endif
                            "  call Dret("s:SetBufWinVars")

FUNCTION  netrw#LocalBrowseCheck()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:10738
Called 8 times
Total time:   0.103112
 Self time:   0.000247

count  total (s)   self (s)
                              " This function is called by netrwPlugin.vim's s:LocalBrowseCheck(), s:NetrwRexplore(),
                              " and by <cr> when atop a listed file/directory (via a buffer-local map)
                              "
                              " unfortunate interaction -- split window debugging can't be used here, must use
                              "                            D-echoRemOn or D-echoTabOn as the BufEnter event triggers
                              "                            another call to LocalBrowseCheck() when attempts to write
                              "                            to the DBG buffer are made.
                              "
                              " The &ft == "netrw" test was installed because the BufEnter event
                              " would hit when re-entering netrw windows, creating unexpected
                              " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
                            "  call Dfunc("netrw#LocalBrowseCheck(dirname<".a:dirname.">)")
                            "  call Decho("isdir<".a:dirname."> =".isdirectory(s:NetrwFile(a:dirname)).((exists("s:treeforceredraw")? " treeforceredraw" : "")).'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                              " getting E930: Cannot use :redir inside execute
                            ""  call Dredir("ls!","netrw#LocalBrowseCheck")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Decho("current buffer#".bufnr("%")."<".bufname("%")."> ft=".&ft,'~'.expand("<slnum>"))
                            
    8              0.000009   let ykeep= @@
    8   0.000237   0.000054   if isdirectory(s:NetrwFile(a:dirname))
                            "   call Decho("is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse,'~'.expand("<slnum>"))
                            
    7              0.000028    if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
                            "    call Decho("case 1 : ft=".&ft,'~'.expand("<slnum>"))
                            "    call Decho("s:rexposn_".bufnr("%")."<".bufname("%")."> ".(exists("s:rexposn_".bufnr("%"))? "exists" : "does not exist"),'~'.expand("<slnum>"))
    7   0.102738   0.000056     sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
                            
                               elseif &ft == "netrw" && line("$") == 1
                            "    call Decho("case 2 (ftâ‰¡netrw && line($)â‰¡1)",'~'.expand("<slnum>"))
                                sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
                            
                               elseif exists("s:treeforceredraw")
                            "    call Decho("case 3 (treeforceredraw)",'~'.expand("<slnum>"))
                                unlet s:treeforceredraw
                                sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
    7              0.000002    endif
                            "   call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "   call Dret("netrw#LocalBrowseCheck")
    7              0.000002    return
    1              0.000000   endif
                            
                              " The following code wipes out currently unused netrw buffers
                              "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
                              "   AND IF the listing style is not a tree listing
    1              0.000002   if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
                            "   call Decho("wiping out currently unused netrw buffers",'~'.expand("<slnum>"))
                               let ibuf    = 1
                               let buflast = bufnr("$")
                               while ibuf <= buflast
                                if bufwinnr(ibuf) == -1 && isdirectory(s:NetrwFile(bufname(ibuf)))
                                 exe "sil! keepj keepalt ".ibuf."bw!"
                                endif
                                let ibuf= ibuf + 1
                               endwhile
    1              0.000000   endif
    1              0.000001   let @@= ykeep
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                              " not a directory, ignore it
                            "  call Dret("netrw#LocalBrowseCheck : not a directory, ignoring it; dirname<".a:dirname.">")

FUNCTION  <SNR>53_NetrwTreeListing()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:9533
Called 7 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
    7              0.000010   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "   call Dfunc("s:NetrwTreeListing() bufname<".expand("%").">")
                            "   call Decho("curdir<".a:dirname.">",'~'.expand("<slnum>"))
                            "   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exist")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"),'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                               " update the treetop
                               if !exists("w:netrw_treetop")
                            "    call Decho("update the treetop  (w:netrw_treetop doesn't exist yet)",'~'.expand("<slnum>"))
                                let w:netrw_treetop= a:dirname
                                let s:netrw_treetop= w:netrw_treetop
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (reusing)",'~'.expand("<slnum>"))
                               elseif (w:netrw_treetop =~ ('^'.a:dirname) && s:Strlen(a:dirname) < s:Strlen(w:netrw_treetop)) || a:dirname !~ ('^'.w:netrw_treetop)
                            "    call Decho("update the treetop  (override w:netrw_treetop with a:dirname<".a:dirname.">)",'~'.expand("<slnum>"))
                                let w:netrw_treetop= a:dirname
                                let s:netrw_treetop= w:netrw_treetop
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (went up)",'~'.expand("<slnum>"))
                               endif
                               if exists("w:netrw_treetop")
                                let s:netrw_treetop= w:netrw_treetop
                               else
                                let w:netrw_treetop= getcwd()
                                let s:netrw_treetop= w:netrw_treetop
                               endif
                            
                               if !exists("w:netrw_treedict")
                                " insure that we have a treedict, albeit empty
                            "    call Decho("initializing w:netrw_treedict to empty",'~'.expand("<slnum>"))
                                let w:netrw_treedict= {}
                               endif
                            
                               " update the dictionary for the current directory
                            "   call Decho("updating: w:netrw_treedict[".a:dirname.'] -> [directory listing]','~'.expand("<slnum>"))
                            "   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." line($)=".line("$"),'~'.expand("<slnum>"))
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d _'
                               let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
                            "   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]),'~'.expand("<slnum>"))
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt.",$d _"
                            
                               " if past banner, record word
                               if exists("w:netrw_bannercnt") && line(".") > w:netrw_bannercnt
                                let fname= expand("<cword>")
                               else
                                let fname= ""
                               endif
                            "   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                               " display from treetop on down
                            "   call Decho("(s:NetrwTreeListing) w:netrw_treetop<".w:netrw_treetop.">")
                               NetrwKeepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
                            "   call Decho("s:NetrwTreeDisplay) setl noma nomod ro",'~'.expand("<slnum>"))
                            
                               " remove any blank line remaining as line#1 (happens in treelisting mode with banner suppressed)
                               while getline(1) =~ '^\s*$' && byte2line(1) > 0
                            "    call Decho("deleting blank line",'~'.expand("<slnum>"))
                                1d
                               endwhile
                            
                               exe "setl ".g:netrw_bufsettings
                            
                            "   call Dret("s:NetrwTreeListing : bufname<".expand("%").">")
                               return
    7              0.000002   endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:15
Called 34 times
Total time:   0.043751
 Self time:   0.039577

count  total (s)   self (s)
   34              0.000056     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
   34              0.000011     endif
                            
   34              0.000060     let s = expand("<amatch>")
   34              0.000027     if s != ""
   34              0.000075       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
   34              0.000009       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   68              0.000142       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   34   0.043065   0.038890         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   68              0.000058       endfor
   34              0.000014     endif

FUNCTION  <SNR>53_NetrwTgtMenu()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:9230
Called 7 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    7              0.000006   if !exists("s:netrw_menucnt")
    7              0.000002    return
                              endif
                            "  call Dfunc("s:NetrwTgtMenu()")
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)",'~'.expand("<slnum>"))
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Targets'
                               endif
                               if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " try to cull duplicate entries
                               let tgtdict={}
                            
                               " target bookmarked places
                               if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                            "    call Decho("installing bookmarks as easy targets",'~'.expand("<slnum>"))
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                                 if has_key(tgtdict,bmd)
                                  let cnt= cnt + 1
                                  continue
                                 endif
                                 let tgtdict[bmd]= cnt
                                 let ebmd= escape(bmd,g:netrw_menu_escape)
                                 " show bookmarks for goto menu
                            "     call Decho("menu: Targets: ".bmd,'~'.expand("<slnum>"))
                                 exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#MakeTgt('".bmd."')\<cr>"
                                 let cnt= cnt + 1
                                endfor
                               endif
                            
                               " target directory browsing history
                               if exists("g:netrw_dirhistmax") && g:netrw_dirhistmax > 0
                            "    call Decho("installing history as easy targets (histmax=".g:netrw_dirhistmax.")",'~'.expand("<slnum>"))
                                let histcnt = 1
                                while histcnt <= g:netrw_dirhistmax
                                 let priority = g:netrw_dirhistcnt + histcnt
                                 if exists("g:netrw_dirhist_{histcnt}")
                                  let histentry  = g:netrw_dirhist_{histcnt}
                                  if has_key(tgtdict,histentry)
                                   let histcnt = histcnt + 1
                                   continue
                                  endif
                                  let tgtdict[histentry] = histcnt
                                  let ehistentry         = escape(histentry,g:netrw_menu_escape)
                            "      call Decho("menu: Targets: ".histentry,'~'.expand("<slnum>"))
                                  exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#MakeTgt('".histentry."')\<cr>"
                                 endif
                                 let histcnt = histcnt + 1
                                endwhile
                               endif
                              endif
                            "  call Dret("s:NetrwTgtMenu")

FUNCTION  <SNR>53_NetrwBrowseChgDir()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:4755
Called 8 times
Total time:   0.067220
 Self time:   0.001913

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBrowseChgDir(islocal=".a:islocal."> newdir<".a:newdir.">) a:0=".a:0." win#".winnr()." curpos<".string(getpos("."))."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "").">")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            
    8              0.000012   let ykeep= @@
    8              0.000015   if !exists("b:netrw_curdir")
                               " Don't try to change-directory: this can happen, for example, when netrw#ErrorMsg has been called
                               " and the current window is the NetrwMessage window.
                               let @@= ykeep
                            "   call Decho("b:netrw_curdir doesn't exist!",'~'.expand("<slnum>"))
                            "   call Decho("getcwd<".getcwd().">",'~'.expand("<slnum>"))
                            "   call Dredir("ls!","s:NetrwBrowseChgDir")
                            "   call Dret("s:NetrwBrowseChgDir")
                               return
    8              0.000003   endif
                            "  call Decho("b:netrw_curdir<".b:netrw_curdir.">")
                            
                              " NetrwBrowseChgDir; save options and initialize {{{3
                            "  call Decho("saving options",'~'.expand("<slnum>"))
    8   0.000149   0.000043   call s:SavePosn(s:netrw_posn)
    8   0.000734   0.000045   NetrwKeepj call s:NetrwOptionsSave("s:")
    8   0.032416   0.000051   NetrwKeepj call s:NetrwOptionsSafe(a:islocal)
    8              0.000021   if has("win32")
                               let dirname = substitute(b:netrw_curdir,'\\','/','ge')
    8              0.000003   else
    8              0.000011    let dirname = b:netrw_curdir
    8              0.000003   endif
    8              0.000008   let newdir    = a:newdir
    8              0.000008   let dolockout = 0
    8              0.000005   let dorestore = 1
                            "  call Decho("win#".winnr(),'~'.expand("<slnum>"))
                            "  call Decho("dirname<".dirname.">",'~'.expand("<slnum>"))
                            "  call Decho("newdir<".newdir.">",'~'.expand("<slnum>"))
                            
                              " ignore <cr>s when done in the banner
                            "  call Decho('(s:NetrwBrowseChgDir) ignore [return]s when done in banner (g:netrw_banner='.g:netrw_banner.")",'~'.expand("<slnum>"))
    8              0.000005   if g:netrw_banner
                            "   call Decho("win#".winnr()." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." line(.)#".line('.')." line($)#".line("#"),'~'.expand("<slnum>"))
    8              0.000025    if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt && line("$") >= w:netrw_bannercnt
                                if getline(".") =~# 'Quick Help'
                            "     call Decho("#1: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                 let g:netrw_quickhelp= (g:netrw_quickhelp + 1)%len(s:QuickHelp)
                            "     call Decho("#2: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                 setl ma noro nowrap
                                 NetrwKeepj call setline(line('.'),'"   Quick Help: <F1>:help  '.s:QuickHelp[g:netrw_quickhelp])
                                 setl noma nomod nowrap
                                 NetrwKeepj call s:NetrwOptionsRestore("s:")
                            "     call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                endif
    8              0.000002    endif
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner." (no banner)",'~'.expand("<slnum>"))
    8              0.000002   endif
                            
                              " set up o/s-dependent directory recognition pattern
    8              0.000013   if has("amiga")
                               let dirpat= '[\/:]$'
    8              0.000003   else
    8              0.000006    let dirpat= '[\/]$'
    8              0.000002   endif
                            "  call Decho("set up o/s-dependent directory recognition pattern: dirname<".dirname.">  dirpat<".dirpat.">",'~'.expand("<slnum>"))
                            
    8              0.000036   if dirname !~ dirpat
                               " apparently vim is "recognizing" that it is in a directory and
                               " is removing the trailing "/".  Bad idea, so let's put it back.
    8              0.000011    let dirname= dirname.'/'
                            "   call Decho("adjusting dirname<".dirname.'>  (put trailing "/" back)','~'.expand("<slnum>"))
    8              0.000002   endif
                            
                            "  call Decho("[newdir<".newdir."> ".((newdir =~ dirpat)? "=~" : "!~")." dirpat<".dirpat.">] && [islocal=".a:islocal."] && [newdir is ".(isdirectory(s:NetrwFile(newdir))? "" : "not ")."a directory]",'~'.expand("<slnum>"))
    8   0.000097   0.000048   if newdir !~ dirpat && !(a:islocal && isdirectory(s:NetrwFile(s:ComposePath(dirname,newdir))))
                               " ------------------------------
                               " NetrwBrowseChgDir: edit a file {{{3
                               " ------------------------------
                            "   call Decho('edit-a-file: case "handling a file": win#'.winnr().' newdir<'.newdir.'> !~ dirpat<'.dirpat.">",'~'.expand("<slnum>"))
                            
                               " save position for benefit of Rexplore
    1              0.000004    let s:rexposn_{bufnr("%")}= winsaveview()
                            "   call Decho("edit-a-file: saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
                            "   call Decho("edit-a-file: win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft,'~'.expand("<slnum>"))
                            "   call Decho("edit-a-file: w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a')." w:netrw_treedict:".(exists("w:netrw_treedict")? "exists" : 'n/a')." newdir<".newdir.">",'~'.expand("<slnum>"))
                            
    1              0.000002    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict") && newdir !~ '^\(/\|\a:\)'
                            "    call Decho("edit-a-file: handle tree listing: w:netrw_treedict<".(exists("w:netrw_treedict")? string(w:netrw_treedict) : 'n/a').">",'~'.expand("<slnum>"))
                            "    call Decho("edit-a-file: newdir<".newdir.">",'~'.expand("<slnum>"))
                            "    let newdir = s:NetrwTreePath(s:netrw_treetop)
                            "    call Decho("edit-a-file: COMBAK why doesn't this recognize file1's directory???")
                                let dirname= s:NetrwTreeDir(a:islocal)
                                "COMBAK : not working for a symlink -- but what about a regular file? a directory?
                            "    call Decho("COMBAK : not working for a symlink -- but what about a regular file? a directory?")
                                " Feb 17, 2019: following if-else-endif restored -- wasn't editing a file in tree mode
                                if dirname =~ '/$'
                                 let dirname= dirname.newdir
                                else
                                 let dirname= dirname."/".newdir
                                endif
                            "    call Decho("edit-a-file: dirname<".dirname.">",'~'.expand("<slnum>"))
                            "    call Decho("edit-a-file: tree listing",'~'.expand("<slnum>"))
    1              0.000002    elseif newdir =~ '^\(/\|\a:\)'
                            "    call Decho("edit-a-file: handle an url or path starting with /: <".newdir.">",'~'.expand("<slnum>"))
                                let dirname= newdir
    1              0.000000    else
    1   0.000028   0.000003     let dirname= s:ComposePath(dirname,newdir)
    1              0.000000    endif
                            "   call Decho("edit-a-file: handling a file: dirname<".dirname."> (a:0=".a:0.")",'~'.expand("<slnum>"))
                               " this lets netrw#BrowseX avoid the edit
    1              0.000001    if a:0 < 1
                            "    call Decho("edit-a-file: (a:0=".a:0."<1) set up windows for editing<".fnameescape(dirname).">  didsplit=".(exists("s:didsplit")? s:didsplit : "doesn't exist"),'~'.expand("<slnum>"))
    1   0.000647   0.000005     NetrwKeepj call s:NetrwOptionsRestore("s:")
    1              0.000001     let curdir= b:netrw_curdir
    1              0.000001     if !exists("s:didsplit")
                            "     "     call Decho("edit-a-file: s:didsplit does not exist; g:netrw_browse_split=".string(g:netrw_browse_split)." win#".winnr()." g:netrw_chgwin=".g:netrw_chgwin",'~'.expand("<slnum>"))
    1              0.000001      if type(g:netrw_browse_split) == 3
                                  " open file in server
                                  " Note that g:netrw_browse_split is a List: [servername,tabnr,winnr]
                            "      call Decho("edit-a-file: open file in server",'~'.expand("<slnum>"))
                                  call s:NetrwServerEdit(a:islocal,dirname)
                            "      call Dret("s:NetrwBrowseChgDir")
                                  return
                            
    1              0.000001      elseif g:netrw_browse_split == 1
                                  " horizontally splitting the window first
                            "      call Decho("edit-a-file: horizontally splitting window prior to edit",'~'.expand("<slnum>"))
                                  let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
                                  exe "keepalt ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
                                  if !&ea
                                   keepalt wincmd _
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                            
    1              0.000001      elseif g:netrw_browse_split == 2
                                  " vertically splitting the window first
                            "      call Decho("edit-a-file: vertically splitting window prior to edit",'~'.expand("<slnum>"))
                                  let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
                                  exe "keepalt ".(g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s"
                                  if !&ea
                                   keepalt wincmd |
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                            
    1              0.000000      elseif g:netrw_browse_split == 3
                                  " open file in new tab
                            "      call Decho("edit-a-file: opening new tab prior to edit",'~'.expand("<slnum>"))
                                  keepalt tabnew
                                  if !exists("b:netrw_curdir")
                                   let b:netrw_curdir= getcwd()
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                            
    1              0.000000      elseif g:netrw_browse_split == 4
                                  " act like "P" (ie. open previous window)
                            "      call Decho("edit-a-file: use previous window for edit",'~'.expand("<slnum>"))
                                  if s:NetrwPrevWinOpen(2) == 3
                                   let @@= ykeep
                            "       call Dret("s:NetrwBrowseChgDir")
                                   return
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                            
    1              0.000000      else
                                  " handling a file, didn't split, so remove menu
                            "      call Decho("edit-a-file: handling a file+didn't split, so remove menu",'~'.expand("<slnum>"))
    1   0.000114   0.000004       call s:NetrwMenu(0)
                                  " optional change to window
    1              0.000001       if g:netrw_chgwin >= 1
                            "       call Decho("edit-a-file: changing window to #".g:netrw_chgwin.": (due to g:netrw_chgwin)",'~'.expand("<slnum>"))
                                   if winnr("$")+1 == g:netrw_chgwin
                                   " if g:netrw_chgwin is set to one more than the last window, then
                                   " vertically split the last window to make that window available.
                                   let curwin= winnr()
                                   exe "NetrwKeepj keepalt ".winnr("$")."wincmd w"
                                   vs
                                   exe "NetrwKeepj keepalt ".g:netrw_chgwin."wincmd ".curwin
                                   endif
                                   exe "NetrwKeepj keepalt ".g:netrw_chgwin."wincmd w"
    1              0.000000       endif
    1   0.000012   0.000005       call s:SetRexDir(a:islocal,curdir)
    1              0.000000      endif
                            
    1              0.000000     endif
                            
                                " the point where netrw actually edits the (local) file
                                " if its local only: LocalBrowseCheck() doesn't edit a file, but NetrwBrowse() will
                                " use keepalt to support  :e #  to return to a directory listing
    1              0.000001     if !&mod
                                 " if e the new file would fail due to &mod, then don't change any of the flags
    1              0.000001      let dolockout= 1
    1              0.000000     endif
    1              0.000000     if a:islocal
                            "     call Decho("edit-a-file: edit local file: exe e! ".fnameescape(dirname),'~'.expand("<slnum>"))
                                 " some like c-^ to return to the last edited file
                                 " others like c-^ to return to the netrw buffer
                                 " Apr 30, 2020: used to have e! here.  That can cause loss of a modified file,
                                 " so emit error E37 instead.
    1   0.025140   0.000010      call s:NetrwEditFile("e","",dirname)
                            "     call Decho("edit-a-file: after e ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod,'~'.expand("<slnum>"))
                                 " COMBAK -- cuc cul related
    1   0.000031   0.000008      call s:NetrwCursor(1)
    1              0.000002      if &hidden || &bufhidden == "hide"
                                  " file came from vim's hidden storage.  Don't "restore" options with it.
    1              0.000001       let dorestore= 0
    1              0.000000      endif
                                else
                            "     call Decho("edit-a-file: remote file: NetrwBrowse will edit it",'~'.expand("<slnum>"))
    1              0.000000     endif
                            
                                " handle g:Netrw_funcref -- call external-to-netrw functions
                                "   This code will handle g:Netrw_funcref as an individual function reference
                                "   or as a list of function references.  It will ignore anything that's not
                                "   a function reference.  See  :help Funcref  for information about function references.
    1              0.000001     if exists("g:Netrw_funcref")
                            "     call Decho("edit-a-file: handle optional Funcrefs",'~'.expand("<slnum>"))
                                 if type(g:Netrw_funcref) == 2
                            "      call Decho("edit-a-file: handling a g:Netrw_funcref",'~'.expand("<slnum>"))
                                  NetrwKeepj call g:Netrw_funcref()
                                 elseif type(g:Netrw_funcref) == 3
                            "      call Decho("edit-a-file: handling a list of g:Netrw_funcrefs",'~'.expand("<slnum>"))
                                  for Fncref in g:Netrw_funcref
                                   if type(Fncref) == 2
                                    NetrwKeepj call Fncref()
                                   endif
                                  endfor
                                 endif
    1              0.000000     endif
    1              0.000000    endif
                            
    7              0.000015   elseif newdir =~ '^/'
                               " ----------------------------------------------------
                               " NetrwBrowseChgDir: just go to the new directory spec {{{3
                               " ----------------------------------------------------
                            "   call Decho('goto-newdir: case "just go to new directory spec": newdir<'.newdir.'>','~'.expand("<slnum>"))
                               let dirname = newdir
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                               NetrwKeepj call s:NetrwOptionsRestore("s:")
                               norm! m`
                            
    7              0.000006   elseif newdir == './'
                               " ---------------------------------------------
                               " NetrwBrowseChgDir: refresh the directory list {{{3
                               " ---------------------------------------------
                            "   call Decho('(s:NetrwBrowseChgDir)refresh-dirlist: case "refresh directory listing": newdir == "./"','~'.expand("<slnum>"))
    4   0.000069   0.000028    NetrwKeepj call s:SetRexDir(a:islocal,dirname)
    4              0.000064    norm! m`
                            
    3              0.000002   elseif newdir == '../'
                               " --------------------------------------
                               " NetrwBrowseChgDir: go up one directory {{{3
                               " --------------------------------------
                            "   call Decho('(s:NetrwBrowseChgDir)go-up: case "go up one directory": newdir == "../"','~'.expand("<slnum>"))
                            
                               if w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                                " force a refresh
                            "    call Decho("go-up: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                            "    call Decho("go-up: setl noro ma",'~'.expand("<slnum>"))
                                setl noro ma
                                NetrwKeepj %d _
                               endif
                            
                               if has("amiga")
                                " amiga
                            "    call Decho('go-up: case "go up one directory": newdir == "../" and amiga','~'.expand("<slnum>"))
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+$\)','\1','')
                                 let dirname= substitute(dirname,'/$','','')
                                else
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+/$\)','\1','')
                                endif
                            "    call Decho("go-up: amiga: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
                            
                               elseif !g:netrw_cygwin && has("win32")
                                " windows
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
                                 if dirname == ""
                                  let dirname= '/'
                                 endif
                                else
                                 let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
                                endif
                                if dirname =~ '^\a:$'
                                 let dirname= dirname.'/'
                                endif
                            "    call Decho("go-up: windows: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
                            
                               else
                                " unix or cygwin
                            "    call Decho('(s:NetrwBrowseChgDir)go-up: case "go up one directory": newdir == "../" and unix or cygwin','~'.expand("<slnum>"))
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
                                 if dirname == ""
                                  let dirname= '/'
                                 endif
                                else
                                 let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
                                endif
                            "    call Decho("go-up: unix: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
                               endif
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                               norm! m`
                            
    3              0.000007   elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " --------------------------------------
                               " NetrwBrowseChgDir: Handle Tree Listing {{{3
                               " --------------------------------------
                            "   call Decho('(s:NetrwBrowseChgDir)tree-list: case liststyle is TREELIST and w:netrw_treedict exists','~'.expand("<slnum>"))
                               " force a refresh (for TREELIST, NetrwTreeDir() will force the refresh)
                            "   call Decho("tree-list: setl noro ma",'~'.expand("<slnum>"))
                               setl noro ma
                               if !(exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir"))
                            "    call Decho("tree-list: clear buffer<".expand("%")."> with :%d  (force refresh)",'~'.expand("<slnum>"))
                                NetrwKeepj %d _
                               endif
                               let treedir      = s:NetrwTreeDir(a:islocal)
                            "   call Decho("tree-list: treedir<".treedir.">",'~'.expand("<slnum>"))
                               let s:treecurpos = winsaveview()
                               let haskey       = 0
                            "   call Decho("tree-list: w:netrw_treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))
                            
                               " search treedict for tree dir as-is
                            "   call Decho("tree-list: search treedict for tree dir as-is",'~'.expand("<slnum>"))
                               if has_key(w:netrw_treedict,treedir)
                            "    call Decho('(s:NetrwBrowseChgDir)tree-list: ....searched for treedir<'.treedir.'> : found it!','~'.expand("<slnum>"))
                                let haskey= 1
                               else
                            "    call Decho('(s:NetrwBrowseChgDir)tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
                               endif
                            
                               " search treedict for treedir with a [/@] appended
                            "   call Decho("tree-list: search treedict for treedir with a [/@] appended",'~'.expand("<slnum>"))
                               if !haskey && treedir !~ '[/@]$'
                                if has_key(w:netrw_treedict,treedir."/")
                                 let treedir= treedir."/"
                            "     call Decho('(s:NetrwBrowseChgDir)tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
                                 let haskey = 1
                                else
                            "     call Decho('(s:NetrwBrowseChgDir)tree-list: ....searched for treedir<'.treedir.'/> : not found','~'.expand("<slnum>"))
                                endif
                               endif
                            
                               " search treedict for treedir with any trailing / elided
                            "   call Decho("tree-list: search treedict for treedir with any trailing / elided",'~'.expand("<slnum>"))
                               if !haskey && treedir =~ '/$'
                                let treedir= substitute(treedir,'/$','','')
                                if has_key(w:netrw_treedict,treedir)
                            "     call Decho('(s:NetrwBrowseChgDir)tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
                                 let haskey = 1
                                else
                            "     call Decho('(s:NetrwBrowseChgDir)tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
                                endif
                               endif
                            
                            "   call Decho("haskey=".haskey,'~'.expand("<slnum>"))
                               if haskey
                                " close tree listing for selected subdirectory
                            "    call Decho("tree-list: closing selected subdirectory<".dirname.">",'~'.expand("<slnum>"))
                                call remove(w:netrw_treedict,treedir)
                            "    call Decho("tree-list: removed     entry<".treedir."> from treedict",'~'.expand("<slnum>"))
                            "    call Decho("tree-list: yielding treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))
                                let dirname= w:netrw_treetop
                               else
                                " go down one directory
                                let dirname= substitute(treedir,'/*$','/','')
                            "    call Decho("tree-list: go down one dir: treedir<".treedir.">",'~'.expand("<slnum>"))
                            "    call Decho("tree-list: ...            : dirname<".dirname.">",'~'.expand("<slnum>"))
                               endif
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                            "   call Decho("setting s:treeforceredraw to true",'~'.expand("<slnum>"))
                               let s:treeforceredraw = 1
                            
    3              0.000001   else
                               " ----------------------------------------
                               " NetrwBrowseChgDir: Go down one directory {{{3
                               " ----------------------------------------
    3   0.000141   0.000024    let dirname    = s:ComposePath(dirname,newdir)
                            "   call Decho("go down one dir: dirname<".dirname."> newdir<".newdir.">",'~'.expand("<slnum>"))
    3   0.000045   0.000020    NetrwKeepj call s:SetRexDir(a:islocal,dirname)
    3              0.000034    norm! m`
    8              0.000003   endif
                            
                             " --------------------------------------
                             " NetrwBrowseChgDir: Restore and Cleanup {{{3
                             " --------------------------------------
    8              0.000005   if dorestore
                               " dorestore is zero'd when a local file was hidden or bufhidden;
                               " in such a case, we want to keep whatever settings it may have.
                            "   call Decho("doing option restore (dorestore=".dorestore.")",'~'.expand("<slnum>"))
    7   0.005886   0.000042    NetrwKeepj call s:NetrwOptionsRestore("s:")
                            "  else " Decho
                            "   call Decho("skipping option restore (dorestore==0): hidden=".&hidden." bufhidden=".&bufhidden." mod=".&mod,'~'.expand("<slnum>"))
    8              0.000003   endif
    8              0.000006   if dolockout && dorestore
                            "   call Decho("restore: filewritable(dirname<".dirname.">)=".filewritable(dirname),'~'.expand("<slnum>"))
                               if filewritable(dirname)
                            "    call Decho("restore: doing modification lockout settings: ma nomod noro",'~'.expand("<slnum>"))
                            "    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
                                setl ma noro nomod
                            "    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                               else
                            "    call Decho("restore: doing modification lockout settings: ma nomod ro",'~'.expand("<slnum>"))
                            "    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
                                setl ma ro nomod
                            "    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                               endif
    8              0.000002   endif
    8   0.000162   0.000031   call s:RestorePosn(s:netrw_posn)
    8              0.000012   let @@= ykeep
                            
                            "  call Dret("s:NetrwBrowseChgDir <".dirname."> : curpos<".string(getpos(".")).">")
    8              0.000007   return dirname

FUNCTION  <SNR>53_NetrwRestoreSetting()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:1916
Called 666 times
Total time:   0.009825
 Self time:   0.008910

count  total (s)   self (s)
                            """  call Dfunc("s:NetrwRestoreSetting(a:keepvar<".a:keepvar."> a:setting<".a:setting.">)")
                            
                              " typically called from s:NetrwOptionsRestore
                              "   call s:NetrwRestoreSettings(keep-option-variable-name,'associated-option')
                              "   ex. call s:NetrwRestoreSetting(a:vt."netrw_selkeep","&l:sel")
                              "  Restores option (but only if different) from a:keepvar
  666              0.000594   if exists(a:keepvar)
  666              0.000951    exe "let keepvarval= ".a:keepvar
  666              0.000954    exe "let setting= ".a:setting
                            
                            ""   call Decho("fyi: a:keepvar<".a:keepvar."> exists")
                            ""   call Decho("fyi: keepvarval=".keepvarval)
                            ""   call Decho("fyi: a:setting<".a:setting."> setting<".setting.">")
                            
  666              0.000404    if setting != keepvarval
                            ""    call Decho("restore setting<".a:setting."> (currently=".setting.") to keepvarval<".keepvarval.">")
  146              0.000114     if type(a:setting) == 0
                                 exe "let ".a:setting."= ".keepvarval
  146              0.000103     elseif type(a:setting) == 1
  146   0.001655   0.000739      exe "let ".a:setting."= '".substitute(keepvarval,"'","''","g")."'"
                                else
                                 call netrw#ErrorMsg(s:ERROR,"(s:NetrwRestoreSetting) doesn't know how to restore ".a:keepvar." with a setting of type#".type(a:setting),105)
  146              0.000037     endif
  666              0.000141    endif
                            
  666              0.000756    exe "unlet ".a:keepvar
  666              0.000150   endif
                            
                            ""  call Dret("s:NetrwRestoreSetting")

FUNCTION  <SNR>53_NetrwMaps()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:6415
Called 7 times
Total time:   0.003320
 Self time:   0.003243

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
                            
                              " mouse <Plug> maps: {{{3
    7              0.000007   if g:netrw_mousemaps && g:netrw_retmap
                            "   call Decho("set up Rexplore 2-leftmouse",'~'.expand("<slnum>"))
                               if !hasmapto("<Plug>NetrwReturn")
                                if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
                            "     call Decho("making map for 2-leftmouse",'~'.expand("<slnum>"))
                                 nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
                                elseif maparg("<c-leftmouse>","n") == ""
                            "     call Decho("making map for c-leftmouse",'~'.expand("<slnum>"))
                                 nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
                                endif
                               endif
                               nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
                            "   call Decho("made <Plug>NetrwReturn map",'~'.expand("<slnum>"))
    7              0.000002   endif
                            
                              " generate default <Plug> maps {{{3
    7              0.000188   if !hasmapto('<Plug>NetrwHide')              |nmap <buffer> <silent> <nowait> a	<Plug>NetrwHide_a|endif
    7              0.000059   if !hasmapto('<Plug>NetrwBrowseUpDir')       |nmap <buffer> <silent> <nowait> -	<Plug>NetrwBrowseUpDir|endif
    7              0.000056   if !hasmapto('<Plug>NetrwOpenFile')          |nmap <buffer> <silent> <nowait> %	<Plug>NetrwOpenFile|endif
    7              0.000060   if !hasmapto('<Plug>NetrwBadd_cb')           |nmap <buffer> <silent> <nowait> cb	<Plug>NetrwBadd_cb|endif
    7              0.000083   if !hasmapto('<Plug>NetrwBadd_cB')           |nmap <buffer> <silent> <nowait> cB	<Plug>NetrwBadd_cB|endif
    7              0.000056   if !hasmapto('<Plug>NetrwLcd')               |nmap <buffer> <silent> <nowait> cd	<Plug>NetrwLcd|endif
    7              0.000051   if !hasmapto('<Plug>NetrwSetChgwin')         |nmap <buffer> <silent> <nowait> C	<Plug>NetrwSetChgwin|endif
    7              0.000046   if !hasmapto('<Plug>NetrwRefresh')           |nmap <buffer> <silent> <nowait> <c-l>	<Plug>NetrwRefresh|endif
    7              0.000052   if !hasmapto('<Plug>NetrwLocalBrowseCheck')  |nmap <buffer> <silent> <nowait> <cr>	<Plug>NetrwLocalBrowseCheck|endif
    7              0.000052   if !hasmapto('<Plug>NetrwServerEdit')        |nmap <buffer> <silent> <nowait> <c-r>	<Plug>NetrwServerEdit|endif
    7              0.000093   if !hasmapto('<Plug>NetrwMakeDir')           |nmap <buffer> <silent> <nowait> d	<Plug>NetrwMakeDir|endif
    7              0.000057   if !hasmapto('<Plug>NetrwBookHistHandler_gb')|nmap <buffer> <silent> <nowait> gb	<Plug>NetrwBookHistHandler_gb|endif
                            " ---------------------------------------------------------------------
                            "  if !hasmapto('<Plug>NetrwForceChgDir')       |nmap <buffer> <silent> <nowait> gd	<Plug>NetrwForceChgDir|endif
                            "  if !hasmapto('<Plug>NetrwForceFile')         |nmap <buffer> <silent> <nowait> gf	<Plug>NetrwForceFile|endif
                            "  if !hasmapto('<Plug>NetrwHidden')            |nmap <buffer> <silent> <nowait> gh	<Plug>NetrwHidden|endif
                            "  if !hasmapto('<Plug>NetrwSetTreetop')        |nmap <buffer> <silent> <nowait> gn	<Plug>NetrwSetTreetop|endif
                            "  if !hasmapto('<Plug>NetrwChgPerm')           |nmap <buffer> <silent> <nowait> gp	<Plug>NetrwChgPerm|endif
                            "  if !hasmapto('<Plug>NetrwBannerCtrl')        |nmap <buffer> <silent> <nowait> I	<Plug>NetrwBannerCtrl|endif
                            "  if !hasmapto('<Plug>NetrwListStyle')         |nmap <buffer> <silent> <nowait> i	<Plug>NetrwListStyle|endif
                            "  if !hasmapto('<Plug>NetrwMarkMoveMF2Arglist')|nmap <buffer> <silent> <nowait> ma	<Plug>NetrwMarkMoveMF2Arglist|endif
                            "  if !hasmapto('<Plug>NetrwMarkMoveArglist2MF')|nmap <buffer> <silent> <nowait> mA	<Plug>NetrwMarkMoveArglist2MF|endif
                            "  if !hasmapto('<Plug>NetrwBookHistHandler_mA')|nmap <buffer> <silent> <nowait> mb	<Plug>NetrwBookHistHandler_mA|endif
                            "  if !hasmapto('<Plug>NetrwBookHistHandler_mB')|nmap <buffer> <silent> <nowait> mB	<Plug>NetrwBookHistHandler_mB|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileCopy')      |nmap <buffer> <silent> <nowait> mc	<Plug>NetrwMarkFileCopy|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileDiff')      |nmap <buffer> <silent> <nowait> md	<Plug>NetrwMarkFileDiff|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileEdit')      |nmap <buffer> <silent> <nowait> me	<Plug>NetrwMarkFileEdit|endif
                            "  if !hasmapto('<Plug>NetrwMarkFile')          |nmap <buffer> <silent> <nowait> mf	<Plug>NetrwMarkFile|endif
                            "  if !hasmapto('<Plug>NetrwUnmarkList')        |nmap <buffer> <silent> <nowait> mF	<Plug>NetrwUnmarkList|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileGrep')      |nmap <buffer> <silent> <nowait> mg	<Plug>NetrwMarkFileGrep|endif
                            "  if !hasmapto('<Plug>NetrwMarkHideSfx')       |nmap <buffer> <silent> <nowait> mh	<Plug>NetrwMarkHideSfx|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileMove')      |nmap <buffer> <silent> <nowait> mm	<Plug>NetrwMarkFileMove|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileRegexp')    |nmap <buffer> <silent> <nowait> mr	<Plug>NetrwMarkFileRegexp|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileSource')    |nmap <buffer> <silent> <nowait> ms	<Plug>NetrwMarkFileSource|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileTag')       |nmap <buffer> <silent> <nowait> mT	<Plug>NetrwMarkFileTag|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileTgt')       |nmap <buffer> <silent> <nowait> mt	<Plug>NetrwMarkFileTgt|endif
                            "  if !hasmapto('<Plug>NetrwUnMarkFile')        |nmap <buffer> <silent> <nowait> mu	<Plug>NetrwUnMarkFile|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileVimCmd')    |nmap <buffer> <silent> <nowait> mv	<Plug>NetrwMarkFileVimCmd|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileExe_mx')    |nmap <buffer> <silent> <nowait> mx	<Plug>NetrwMarkFileExe_mx|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileExe_mX')    |nmap <buffer> <silent> <nowait> mX	<Plug>NetrwMarkFileExe_mX|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileCompress')  |nmap <buffer> <silent> <nowait> mz	<Plug>NetrwMarkFileCompress|endif
                            "  if !hasmapto('<Plug>NetrwObtain')            |nmap <buffer> <silent> <nowait> O	<Plug>NetrwObtain|endif
                            "  if !hasmapto('<Plug>NetrwSplit_o')           |nmap <buffer> <silent> <nowait> o	<Plug>NetrwSplit_o|endif
                            "  if !hasmapto('<Plug>NetrwPreview')           |nmap <buffer> <silent> <nowait> p	<Plug>NetrwPreview|endif
                            "  if !hasmapto('<Plug>NetrwPrevWinOpen')       |nmap <buffer> <silent> <nowait> P	<Plug>NetrwPrevWinOpen|endif
                            "  if !hasmapto('<Plug>NetrwBookHistHandler_qb')|nmap <buffer> <silent> <nowait> qb	<Plug>NetrwBookHistHandler_qb|endif
                            "  if !hasmapto('<Plug>NetrwFileInfo')          |nmap <buffer> <silent> <nowait> qf	<Plug>NetrwFileInfo|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileQFEL_qF')   |nmap <buffer> <silent> <nowait> qF	<Plug>NetrwMarkFileQFEL_qF|endif
                            "  if !hasmapto('<Plug>NetrwMarkFileQFEL_qL')   |nmap <buffer> <silent> <nowait> qL	<Plug>NetrwMarkFileQFEL_qL|endif
                            "  if !hasmapto('<Plug>NetrwSortStyle')         |nmap <buffer> <silent> <nowait> s	<Plug>NetrwSortStyle|endif
                            "  if !hasmapto('<Plug>NetSortSequence')        |nmap <buffer> <silent> <nowait> S	<Plug>NetSortSequence|endif
                            "  if !hasmapto('<Plug>NetrwSetTgt_Tb')         |nmap <buffer> <silent> <nowait> Tb	<Plug>NetrwSetTgt_Tb|endif
                            "  if !hasmapto('<Plug>NetrwSetTgt_Th')         |nmap <buffer> <silent> <nowait> Th	<Plug>NetrwSetTgt_Th|endif
                            "  if !hasmapto('<Plug>NetrwSplit_t')           |nmap <buffer> <silent> <nowait> t	<Plug>NetrwSplit_t|endif
                            "  if !hasmapto('<Plug>NetrwBookHistHandler_u') |nmap <buffer> <silent> <nowait> u	<Plug>NetrwBookHistHandler_u|endif
                            "  if !hasmapto('<Plug>NetrwBookHistHandler_U') |nmap <buffer> <silent> <nowait> U	<Plug>NetrwBookHistHandler_U|endif
                            "  if !hasmapto('<Plug>NetrwSplit_v')           |nmap <buffer> <silent> <nowait> v	<Plug>NetrwSplit_v|endif
                            "  if !hasmapto('<Plug>NetrwBrowseX')           |nmap <buffer> <silent> <nowait> x	<Plug>NetrwBrowseX|endif
                            "  if !hasmapto('<Plug>NetrwLocalExecute')      |nmap <buffer> <silent> <nowait> X	<Plug>NetrwLocalExecute|endif
                            
    7              0.000004   if a:islocal
                            "   call Decho("make local maps",'~'.expand("<slnum>"))
                               " local normal-mode maps {{{3
    7              0.000025    nnoremap <buffer> <silent> <Plug>NetrwHide_a			:<c-u>call <SID>NetrwHide(1)<cr>
    7              0.000018    nnoremap <buffer> <silent> <Plug>NetrwBrowseUpDir		:<c-u>call <SID>NetrwBrowseUpDir(1)<cr>
    7              0.000018    nnoremap <buffer> <silent> <Plug>NetrwOpenFile		:<c-u>call <SID>NetrwOpenFile(1)<cr>
    7              0.000014    nnoremap <buffer> <silent> <Plug>NetrwBadd_cb		:<c-u>call <SID>NetrwBadd(1,0)<cr>
    7              0.000017    nnoremap <buffer> <silent> <Plug>NetrwBadd_cB		:<c-u>call <SID>NetrwBadd(1,1)<cr>
    7              0.000015    nnoremap <buffer> <silent> <Plug>NetrwLcd			:<c-u>call <SID>NetrwLcd(b:netrw_curdir)<cr>
    7              0.000016    nnoremap <buffer> <silent> <Plug>NetrwSetChgwin		:<c-u>call <SID>NetrwSetChgwin()<cr>
    7              0.000026    nnoremap <buffer> <silent> <Plug>NetrwLocalBrowseCheck	:<c-u>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
    7              0.000022    nnoremap <buffer> <silent> <Plug>NetrwServerEdit		:<c-u>call <SID>NetrwServerEdit(3,<SID>NetrwGetWord())<cr>
    7              0.000019    nnoremap <buffer> <silent> <Plug>NetrwMakeDir		:<c-u>call <SID>NetrwMakeDir("")<cr>
    7              0.000028    nnoremap <buffer> <silent> <Plug>NetrwBookHistHandler_gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                            " ---------------------------------------------------------------------
    7              0.000015    nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
    7              0.000013    nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
    7              0.000011    nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
    7              0.000014    nnoremap <buffer> <silent> <nowait> gn	:<c-u>call netrw#SetTreetop(0,<SID>NetrwGetWord())<cr>
    7              0.000012    nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
    7              0.000014    nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
    7              0.000011    nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(1)<cr>
    7              0.000013    nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(1,0)<cr>
    7              0.000012    nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(1,1)<cr>
    7              0.000015    nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
    7              0.000016    nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
    7              0.000013    nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
    7              0.000012    nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
    7              0.000012    nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
    7              0.000013    nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
    7              0.000016    nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
    7              0.000012    nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
    7              0.000015    nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
    7              0.000014    nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
    7              0.000011    nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
    7              0.000015    nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
    7              0.000014    nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
    7              0.000015    nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
    7              0.000012    nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
    7              0.000015    nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
    7              0.000013    nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(1,0)<cr>
    7              0.000013    nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(1,1)<cr>
    7              0.000013    nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
    7              0.000010    nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(1)<cr>
    7              0.000010    nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(3)<cr>
    7              0.000017    nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
    7              0.000010    nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(1)<cr>
    7              0.000016    nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
    7              0.000014    nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
    7              0.000011    nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
    7              0.000012    nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(1,getloclist(v:count))<cr>
    7              0.000009    nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(1)<cr>
    7              0.000011    nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(1)<cr>
    7              0.000012    nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(1,'b',v:count1)<cr>
    7              0.000017    nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(4)<cr>
    7              0.000013    nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(1,'h',v:count)<cr>
    7              0.000012    nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
    7              0.000014    nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
    7              0.000009    nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(5)<cr>
    7              0.000018    nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
    7              0.000018    nnoremap <buffer> <silent> <nowait> X	:<c-u>call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
                            
    7              0.000030    nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
    7              0.000077    if !hasmapto('<Plug>NetrwHideEdit')
    7              0.000089     nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
    7              0.000003    endif
    7              0.000017    nnoremap <buffer> <silent> <Plug>NetrwHideEdit		:call <SID>NetrwHideEdit(1)<cr>
    7              0.000048    if !hasmapto('<Plug>NetrwRefresh')
                                nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
    7              0.000002    endif
    7              0.000040    nnoremap <buffer> <silent> <Plug>NetrwRefresh		<c-l>:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,(exists("w:netrw_liststyle") && exists("w:netrw_treetop") && w:netrw_liststyle == 3)? w:netrw_treetop : './'))<cr>
    7              0.000040    if s:didstarstar || !mapcheck("<s-down>","n")
    7              0.000011     nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
    7              0.000002    endif
    7              0.000024    if s:didstarstar || !mapcheck("<s-up>","n")
    7              0.000008     nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
    7              0.000002    endif
    7              0.000070    if !hasmapto('<Plug>NetrwTreeSqueeze')
    3              0.000005     nmap <buffer> <silent> <nowait> <s-cr>			<Plug>NetrwTreeSqueeze
    7              0.000002    endif
    7              0.000017    nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze		:call <SID>TreeSqueezeDir(1)<cr>
    7              0.000017    let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
    7              0.000005    if g:netrw_mousemaps == 1
    7              0.000016     nmap <buffer>			<leftmouse>   		<Plug>NetrwLeftmouse
    7              0.000016     nmap <buffer>			<c-leftmouse>		<Plug>NetrwCLeftmouse
    7              0.000013     nmap <buffer>			<middlemouse>		<Plug>NetrwMiddlemouse
    7              0.000016     nmap <buffer>			<s-leftmouse>		<Plug>NetrwSLeftmouse
    7              0.000013     nmap <buffer>			<s-leftdrag>		<Plug>NetrwSLeftdrag
    7              0.000013     nmap <buffer>			<2-leftmouse>		<Plug>Netrw2Leftmouse
    7              0.000013     imap <buffer>			<leftmouse>		<Plug>ILeftmouse
    7              0.000012     imap <buffer>			<middlemouse>		<Plug>IMiddlemouse
    7              0.000023     nno  <buffer> <silent>		<Plug>NetrwLeftmouse	:exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwLeftmouse(1)<cr>
    7              0.000022     nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	:exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwCLeftmouse(1)<cr>
    7              0.000022     nno  <buffer> <silent>		<Plug>NetrwMiddlemouse	:exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwPrevWinOpen(1)<cr>
    7              0.000021     nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	:exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwSLeftmouse(1)<cr>
    7              0.000020     nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	:exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwSLeftdrag(1)<cr>
    7              0.000010     nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
    7              0.000045     exe 'nnoremap <buffer> <silent> <rightmouse>  :exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    7              0.000043     exe 'vnoremap <buffer> <silent> <rightmouse>  :exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    7              0.000002    endif
    7              0.000030    exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    7              0.000023    exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    7              0.000023    exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
    7              0.000017    exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("")<cr>'
    7              0.000025    exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    7              0.000022    exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    7              0.000023    exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
    7              0.000011    nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
                            
                               " support user-specified maps
    7   0.000114   0.000036    call netrw#UserMaps(1)
                            
                              else
                               " remote normal-mode maps {{{3
                            "   call Decho("make remote maps",'~'.expand("<slnum>"))
                               call s:RemotePathAnalysis(b:netrw_curdir)
                               nnoremap <buffer> <silent> <Plug>NetrwHide_a			:<c-u>call <SID>NetrwHide(0)<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwBrowseUpDir		:<c-u>call <SID>NetrwBrowseUpDir(0)<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwOpenFile		:<c-u>call <SID>NetrwOpenFile(0)<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwBadd_cb		:<c-u>call <SID>NetrwBadd(0,0)<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwBadd_cB		:<c-u>call <SID>NetrwBadd(0,1)<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwLcd			:<c-u>call <SID>NetrwLcd(b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwSetChgwin		:<c-u>call <SID>NetrwSetChgwin()<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwRefresh		:<c-u>call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwLocalBrowseCheck	:<c-u>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwServerEdit		:<c-u>call <SID>NetrwServerEdit(2,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <Plug>NetrwBookHistHandler_gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                            " ---------------------------------------------------------------------
                               nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
                               nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
                               nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(0)<cr>
                               nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(0,0)<cr>
                               nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(0,1)<cr>
                               nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
                               nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
                               nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
                               nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(0,0)<cr>
                               nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(0,1)<cr>
                               nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
                               nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(0)<cr>
                               nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(0)<cr>
                               nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(0)<cr>
                               nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
                               nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(0,getloclist(v:count))<cr>
                               nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(0)<cr>
                               nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(0)<cr>
                               nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(0,'b',v:count1)<cr>
                               nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(1)<cr>
                               nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(0,'h',v:count)<cr>
                               nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(2)<cr>
                               nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
                               if !hasmapto('<Plug>NetrwHideEdit')
                                nmap <buffer> <c-h> <Plug>NetrwHideEdit
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
                               if !hasmapto('<Plug>NetrwRefresh')
                                nmap <buffer> <c-l> <Plug>NetrwRefresh
                               endif
                               if !hasmapto('<Plug>NetrwTreeSqueeze')
                                nmap <buffer> <silent> <nowait> <s-cr>	<Plug>NetrwTreeSqueeze
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze	:call <SID>TreeSqueezeDir(0)<cr>
                            
                               let mapsafepath     = escape(s:path, s:netrw_map_escape)
                               let mapsafeusermach = escape(((s:user == "")? "" : s:user."@").s:machine, s:netrw_map_escape)
                            
                               nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               if g:netrw_mousemaps == 1
                                nmap <buffer> <leftmouse>		<Plug>NetrwLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwLeftmouse	:exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwLeftmouse(0)<cr>
                                nmap <buffer> <c-leftmouse>		<Plug>NetrwCLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	:exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwCLeftmouse(0)<cr>
                                nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	:exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwSLeftmouse(0)<cr>
                                nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
                                nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	:exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwSLeftdrag(0)<cr>
                                nmap <middlemouse>			<Plug>NetrwMiddlemouse
                                nno  <buffer> <silent>		<middlemouse>		<Plug>NetrwMiddlemouse :exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwPrevWinOpen(0)<cr>
                                nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
                                nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
                                imap <buffer> <leftmouse>		<Plug>ILeftmouse
                                imap <buffer> <middlemouse>		<Plug>IMiddlemouse
                                imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
                                exe 'nnoremap <buffer> <silent> <rightmouse> :exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                                exe 'vnoremap <buffer> <silent> <rightmouse> :exec "norm! \<lt>leftmouse>"<bar>call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               endif
                               exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
                            
                               " support user-specified maps
                               call netrw#UserMaps(0)
    7              0.000002   endif " }}}3
                            
                            "  call Dret("s:NetrwMaps")

FUNCTION  <SNR>53_NetrwCursor()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:11792
Called 16 times
Total time:   0.000379
 Self time:   0.000376

count  total (s)   self (s)
   16              0.000028   if !exists("w:netrw_liststyle")
                               let w:netrw_liststyle= g:netrw_liststyle
   16              0.000004   endif
                            "  call Dfunc("s:NetrwCursor() ft<".&ft."> liststyle=".w:netrw_liststyle." g:netrw_cursor=".g:netrw_cursor." s:netrw_usercuc=".s:netrw_usercuc." s:netrw_usercul=".s:netrw_usercul)
                            
                            "  call Decho("(s:NetrwCursor) COMBAK: cuc=".&l:cuc." cul=".&l:cul)
                            
   16              0.000013   if &ft != "netrw"
                               " if the current window isn't a netrw directory listing window, then use user cursorline/column
                               " settings.  Affects when netrw is used to read/write a file using scp/ftp/etc.
                            "   call Decho("case ft!=netrw: use user cul,cuc",'~'.expand("<slnum>"))
                            
   15              0.000013   elseif g:netrw_cursor == 8
                               if w:netrw_liststyle == s:WIDELIST
                                setl cursorline
                                setl cursorcolumn
                               else
                                setl cursorline
                               endif
   15              0.000008   elseif g:netrw_cursor == 7
                                setl cursorline
   15              0.000007   elseif g:netrw_cursor == 6
                               if w:netrw_liststyle == s:WIDELIST
                                setl cursorline
                               endif
   15              0.000007   elseif g:netrw_cursor == 4
                               " all styles: cursorline, cursorcolumn
                            "   call Decho("case g:netrw_cursor==4: setl cul cuc",'~'.expand("<slnum>"))
                               setl cursorline
                               setl cursorcolumn
                            
   15              0.000008   elseif g:netrw_cursor == 3
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, cursorcolumn
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==3 and wide: setl cul cuc",'~'.expand("<slnum>"))
                                setl cursorline
                                setl cursorcolumn
                               else
                            "    call Decho("case g:netrw_cursor==3 and not wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
                                setl cursorline
                               endif
                            
   15              0.000007   elseif g:netrw_cursor == 2
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, user's cursorcolumn
                            "   call Decho("case g:netrw_cursor==2: setl cuc (use user's cul)",'~'.expand("<slnum>"))
   15   0.000025   0.000022    setl cursorline
                            
                              elseif g:netrw_cursor == 1
                               " thin-long-tree: user's cursorline, user's cursorcolumn
                               " wide          : cursorline,        user's cursorcolumn
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
                                setl cursorline
                               else
                            "    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)",'~'.expand("<slnum>"))
                               endif
                            
                              else
                               " all styles: user's cursorline, user's cursorcolumn
                            "   call Decho("default: (use user's cul,cuc)",'~'.expand("<slnum>"))
                               let &l:cursorline   = s:netrw_usercul
                               let &l:cursorcolumn = s:netrw_usercuc
   16              0.000004   endif
                            
                            " call Decho("(s:NetrwCursor) COMBAK: cuc=".&l:cuc." cul=".&l:cul)
                            "  call Dret("s:NetrwCursor : l:cursorline=".&l:cursorline." l:cursorcolumn=".&l:cursorcolumn)

FUNCTION  GetLuaIndent()
    Defined: /usr/share/nvim/runtime/indent/lua.vim:29
Called 2 times
Total time:   0.000171
 Self time:   0.000057

count  total (s)   self (s)
    2              0.000017     let ignorecase_save = &ignorecase
    2              0.000003   try
    2   0.000022   0.000015     let &ignorecase = 0
    2   0.000114   0.000011     return GetLuaIndentIntern()
    2              0.000002   finally
    2   0.000006   0.000003     let &ignorecase = ignorecase_save
    2              0.000001   endtry

FUNCTION  <SNR>11_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:27
Called 35 times
Total time:   0.034044
 Self time:   0.029134

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   35              0.000209   syn clear
   35              0.000044   if exists("b:current_syntax")
                                unlet b:current_syntax
   35              0.000011   endif
                            
   35              0.000068   0verbose let s = expand("<amatch>")
   35              0.000029   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   35              0.000025   elseif s == "OFF"
                                let s = ""
   35              0.000009   endif
                            
   35              0.000018   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   66              0.000146     for name in split(s, '\.')
   33              0.000033       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   33   0.033085   0.028175         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
   33              0.000018       endif
   66              0.000028     endfor
   35              0.000012   endif

FUNCTION  <SNR>53_NetrwListSettings()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:4480
Called 7 times
Total time:   0.001224
 Self time:   0.000289

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwListSettings(islocal=".a:islocal.")")
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
    7              0.000009   let fname= bufname("%")
                            "  "  call Decho("setl bt=nofile nobl ma nonu nowrap noro nornu",'~'.expand("<slnum>"))
                              "              nobl noma nomod nonu noma nowrap ro   nornu  (std g:netrw_bufsettings)
    7   0.000908   0.000067   setl bt=nofile nobl ma         nonu      nowrap noro nornu
    7   0.000115   0.000034   call s:NetrwBufRename(fname)
    7              0.000005   if g:netrw_use_noswf
    7   0.000013   0.000010    setl noswf
    7              0.000002   endif
                            "  call Dredir("ls!","s:NetrwListSettings")
                            "  call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
    7   0.000025   0.000022   exe "setl ts=".(g:netrw_maxfilenamelen+1)
    7   0.000094   0.000091   setl isk+=.,~,-
    7              0.000007   if g:netrw_fastbrowse > a:islocal
                               setl bh=hide
    7              0.000002   else
    7   0.000017   0.000013    setl bh=delete
    7              0.000002   endif
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwListSettings")

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:14
Called 34 times
Total time:   0.011997
 Self time:   0.011959

count  total (s)   self (s)
   34              0.000057     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
   34              0.000011     endif
   34              0.000055     let s = expand("<amatch>")
   34              0.000031     if s != ""
   34              0.000032       if exists("b:did_indent")
                            	unlet b:did_indent
   34              0.000009       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   68              0.000100       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
   34   0.011497   0.011459         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   68              0.000040       endfor
   34              0.000012     endif

FUNCTION  <SNR>53_NetrwOptionsSave()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:1607
Called 18 times
Total time:   0.001367
 Self time:   0.001367

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionsSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
                            "  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt." hid=".&hid,'~'.expand("<slnum>"))
                            "  call Decho("(s:NetrwOptionsSave) lines=".&lines)
                            
   18              0.000044   if !exists("{a:vt}netrw_optionsave")
   18              0.000032    let {a:vt}netrw_optionsave= 1
                              else
                            "   call Dret("s:NetrwOptionsSave : options already saved")
                               return
   18              0.000005   endif
                            "  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff,'~'.expand("<slnum>"))
                            
                              " Save current settings and current directory
                            "  call Decho("saving current settings and current directory",'~'.expand("<slnum>"))
   18              0.000019   let s:yykeep          = @@
   18              0.000061   if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
   18              0.000029   let {a:vt}netrw_aikeep    = &l:ai
   18              0.000023   let {a:vt}netrw_awkeep    = &l:aw
   18              0.000026   let {a:vt}netrw_bhkeep    = &l:bh
   18              0.000021   let {a:vt}netrw_blkeep    = &l:bl
   18              0.000021   let {a:vt}netrw_btkeep    = &l:bt
   18              0.000023   let {a:vt}netrw_bombkeep  = &l:bomb
   18              0.000023   let {a:vt}netrw_cedit     = &cedit
   18              0.000020   let {a:vt}netrw_cikeep    = &l:ci
   18              0.000024   let {a:vt}netrw_cinkeep   = &l:cin
   18              0.000027   let {a:vt}netrw_cinokeep  = &l:cino
   18              0.000027   let {a:vt}netrw_comkeep   = &l:com
   18              0.000023   let {a:vt}netrw_cpokeep   = &l:cpo
   18              0.000022   let {a:vt}netrw_cuckeep   = &l:cuc
   18              0.000019   let {a:vt}netrw_culkeep   = &l:cul
                            "  call Decho("(s:NetrwOptionsSave) COMBAK: cuc=".&l:cuc." cul=".&l:cul)
   18              0.000022   let {a:vt}netrw_diffkeep  = &l:diff
   18              0.000020   let {a:vt}netrw_fenkeep   = &l:fen
   18              0.000027   if !exists("g:netrw_ffkeep") || g:netrw_ffkeep
   18              0.000026    let {a:vt}netrw_ffkeep    = &l:ff
   18              0.000006   endif
   18              0.000021   let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
   18              0.000023   let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
   18              0.000021   let {a:vt}netrw_gokeep    = &go             " guioptions
   18              0.000022   let {a:vt}netrw_hidkeep   = &l:hidden
   18              0.000022   let {a:vt}netrw_imkeep    = &l:im
   18              0.000022   let {a:vt}netrw_iskkeep   = &l:isk
   18              0.000023   let {a:vt}netrw_lines     = &lines
   18              0.000024   let {a:vt}netrw_lskeep    = &l:ls
   18              0.000021   let {a:vt}netrw_makeep    = &l:ma
   18              0.000025   let {a:vt}netrw_magickeep = &l:magic
   18              0.000021   let {a:vt}netrw_modkeep   = &l:mod
   18              0.000021   let {a:vt}netrw_nukeep    = &l:nu
   18              0.000021   let {a:vt}netrw_rnukeep   = &l:rnu
   18              0.000021   let {a:vt}netrw_repkeep   = &l:report
   18              0.000021   let {a:vt}netrw_rokeep    = &l:ro
   18              0.000022   let {a:vt}netrw_selkeep   = &l:sel
   18              0.000029   let {a:vt}netrw_spellkeep = &l:spell
   18              0.000013   if !g:netrw_use_noswf
                               let {a:vt}netrw_swfkeep  = &l:swf
   18              0.000005   endif
   18              0.000022   let {a:vt}netrw_tskeep    = &l:ts
   18              0.000020   let {a:vt}netrw_twkeep    = &l:tw           " textwidth
   18              0.000024   let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
   18              0.000022   let {a:vt}netrw_wrapkeep  = &l:wrap
   18              0.000023   let {a:vt}netrw_writekeep = &l:write
                            
                              " save a few selected netrw-related variables
                            "  call Decho("saving a few selected netrw-related variables",'~'.expand("<slnum>"))
   18              0.000011   if g:netrw_keepdir
   18              0.000063    let {a:vt}netrw_dirkeep  = getcwd()
                            "   call Decho("saving to ".a:vt."netrw_dirkeep<".{a:vt}netrw_dirkeep.">",'~'.expand("<slnum>"))
   18              0.000005   endif
   18              0.000026   sil! let {a:vt}netrw_slashkeep= @/
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionsSave : tab#".tabpagenr()." win#".winnr())

FUNCTION  <SNR>53_NetrwRefresh()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:8889
Called 4 times
Total time:   0.051135
 Self time:   0.000203

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwRefresh(islocal<".a:islocal.">,dirname=".a:dirname.") g:netrw_hide=".g:netrw_hide." g:netrw_sort_direction=".g:netrw_sort_direction)
                              " at the current time (Mar 19, 2007) all calls to NetrwRefresh() call NetrwBrowseChgDir() first.
    4              0.000013   setl ma noro
                            "  call Decho("setl ma noro",'~'.expand("<slnum>"))
                            "  call Decho("clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
    4              0.000004   let ykeep      = @@
    4              0.000008   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               if !exists("w:netrw_treetop")
                                if exists("b:netrw_curdir")
                                 let w:netrw_treetop= b:netrw_curdir
                                else
                                 let w:netrw_treetop= getcwd()
                                endif
                               endif
                               NetrwKeepj call s:NetrwRefreshTreeDict(w:netrw_treetop)
    4              0.000001   endif
                            
                              " save the cursor position before refresh.
    4              0.000007   let screenposn = winsaveview()
                            "  call Decho("saving posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
                            
                            "  call Decho("win#".winnr().": ".winheight(0)."x".winwidth(0)." curfile<".expand("%").">",'~'.expand("<slnum>"))
                            "  call Decho("clearing buffer prior to refresh",'~'.expand("<slnum>"))
    4              0.000067   sil! NetrwKeepj %d _
    4              0.000003   if a:islocal
    4   0.050954   0.000021    NetrwKeepj call netrw#LocalBrowseCheck(a:dirname)
                              else
                               NetrwKeepj call s:NetrwBrowse(a:islocal,a:dirname)
    4              0.000001   endif
                            
                              " restore position
                            "  call Decho("restoring posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
    4              0.000008   NetrwKeepj call winrestview(screenposn)
                            
                              " restore file marks
    4              0.000007   if has("syntax") && exists("g:syntax_on") && g:syntax_on
    4              0.000009    if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
                            " "   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/",'~'.expand("<slnum>"))
                                exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
    4              0.000001    else
                            " "   call Decho("2match none  (bufnr(%)=".bufnr("%")."<".bufname("%").">)",'~'.expand("<slnum>"))
    4              0.000003     2match none
    4              0.000001    endif
    4              0.000001  endif
                            
                            "  restore
    4              0.000004   let @@= ykeep
                            "  call Dret("s:NetrwRefresh")

FUNCTION  GetLuaIndentIntern()
    Defined: /usr/share/nvim/runtime/indent/lua.vim:39
Called 2 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
    2              0.000007   let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
    2              0.000003   if prevlnum == 0
                                return 0
    2              0.000001   endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
    2              0.000004   let ind = indent(prevlnum)
    2              0.000004   let prevline = getline(prevlnum)
    2              0.000023   let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
    2              0.000001   if midx == -1
    2              0.000008     let midx = match(prevline, '{\s*\%(--\%([^[].*\)\?\)\?$')
    2              0.000001     if midx == -1
    2              0.000007       let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
    2              0.000001     endif
    2              0.000000   endif
                            
    2              0.000001   if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
    2              0.000000   endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until and '}'
                              " This is the part that requires 'indentkeys'.
    2              0.000011   let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\)')
    2              0.000003   if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
    2              0.000000   endif
                            
    2              0.000001   return ind

FUNCTION  <SNR>53_NetrwInsureWinVars()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:12034
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000002   if !exists("w:netrw_liststyle")
                            "   call Dfunc("s:NetrwInsureWinVars() win#".winnr())
                               let curbuf = bufnr("%")
                               let curwin = winnr()
                               let iwin   = 1
                               while iwin <= winnr("$")
                                exe iwin."wincmd w"
                                if winnr() != curwin && bufnr("%") == curbuf && exists("w:netrw_liststyle")
                                 " looks like ctrl-w_s or ctrl-w_v was used to split a netrw buffer
                                 let winvars= w:
                                 break
                                endif
                                let iwin= iwin + 1
                               endwhile
                               exe "keepalt ".curwin."wincmd w"
                               if exists("winvars")
                            "    call Decho("copying w#".iwin." window variables to w#".curwin,'~'.expand("<slnum>"))
                                for k in keys(winvars)
                                 let w:{k}= winvars[k]
                                endfor
                               endif
                            "   call Dret("s:NetrwInsureWinVars win#".winnr())
    2              0.000000   endif

FUNCTION  <SNR>53_SavePosn()
    Defined: /usr/share/nvim/runtime/autoload/netrw.vim:12357
Called 8 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
                            "  call Dfunc("s:SavePosn(posndict) curbuf#".bufnr("%")."<".bufname("%").">")
                            
    8              0.000035   if !exists("a:posndict[bufnr('%')]")
    3              0.000006    let a:posndict[bufnr("%")]= []
    8              0.000003   endif
                            "  call Decho("before push: a:posndict[buf#".bufnr("%")."]=".string(a:posndict[bufnr('%')]))
    8              0.000035   call add(a:posndict[bufnr("%")],winsaveview())
                            "  call Decho("after  push: a:posndict[buf#".bufnr("%")."]=".string(a:posndict[bufnr('%')]))
                            
                            "  call Dret("s:SavePosn posndict")
    8              0.000007   return a:posndict

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    8   0.103112   0.000247  netrw#LocalBrowseCheck()
    7   0.102682   0.001524  <SNR>53_NetrwBrowse()
    6   0.073632   0.000682  <SNR>53_LocalBrowseRefresh()
    8   0.067220   0.001913  <SNR>53_NetrwBrowseChgDir()
    7   0.061742   0.001616  <SNR>53_PerformListing()
   15   0.054368   0.002065  <SNR>53_NetrwOptionsSafe()
    4   0.051135   0.000203  <SNR>53_NetrwRefresh()
   34   0.043751   0.039577  <SNR>1_LoadFTPlugin()
   35   0.034044   0.029134  <SNR>11_SynSet()
   25   0.033226   0.003224  <SNR>53_NetrwOptionsRestore()
    4   0.031172   0.001843  <SNR>53_NetrwEditFile()
    7   0.015191   0.000721  <SNR>53_NetrwGetBuffer()
    3   0.013024   0.000323  <SNR>53_NetrwEnew()
   34   0.011997   0.011959  <SNR>2_LoadIndent()
  666   0.009825   0.008910  <SNR>53_NetrwRestoreSetting()
    7   0.005789   0.003400  <SNR>53_LocalListing()
   16   0.004777   0.000295  <SNR>53_NetrwBufRename()
   73   0.004229   0.003700  <SNR>16_Highlight_Matching_Pair()
    7   0.003570             <SNR>53_NetrwSetSort()
  315   0.003343   0.003307  <SNR>53_NetrwSetSafeSetting()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   34   0.043751   0.039577  <SNR>1_LoadFTPlugin()
   35   0.034044   0.029134  <SNR>11_SynSet()
   34   0.011997   0.011959  <SNR>2_LoadIndent()
  666   0.009825   0.008910  <SNR>53_NetrwRestoreSetting()
   73   0.004229   0.003700  <SNR>16_Highlight_Matching_Pair()
    7              0.003570  <SNR>53_NetrwSetSort()
    7   0.005789   0.003400  <SNR>53_LocalListing()
  315   0.003343   0.003307  <SNR>53_NetrwSetSafeSetting()
    7   0.003320   0.003243  <SNR>53_NetrwMaps()
   25   0.033226   0.003224  <SNR>53_NetrwOptionsRestore()
   15   0.054368   0.002065  <SNR>53_NetrwOptionsSafe()
    8   0.067220   0.001913  <SNR>53_NetrwBrowseChgDir()
    4   0.031172   0.001843  <SNR>53_NetrwEditFile()
   96              0.001626  <SNR>53_NetrwFile()
    7   0.061742   0.001616  <SNR>53_PerformListing()
    7   0.102682   0.001524  <SNR>53_NetrwBrowse()
   18              0.001367  <SNR>53_NetrwOptionsSave()
   14   0.001316   0.000808  <SNR>53_NetrwGlob()
    7   0.015191   0.000721  <SNR>53_NetrwGetBuffer()
    6   0.073632   0.000682  <SNR>53_LocalBrowseRefresh()

